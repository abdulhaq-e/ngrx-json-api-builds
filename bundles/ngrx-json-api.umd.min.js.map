{"version":3,"sources":["../../src/utils.ts","../../src/selectors.ts","../../src/reducers.ts","../../src/module.ts","../../src/interfaces.ts","../../src/actions.ts","../../src/services.ts","../../src/pipes.ts","../../src/api.ts","../../src/effects.ts"],"names":["rollbackResource","newState","type","id","storeResource","persistedResource","state","Object","assign","resource","collectPendingChange","pending","include","includeNew","push","_i","include_1","length","includeElement","relationshipName_1","relationships","data","relationInclude_1","filter","relIncludeElem","forEach","slice","_.isArray","relationId","getPendingChanges","ids","_.isUndefined","keys","relationshipInclusions","include_2","split","_a","ids_1","_.uniqBy","e","getNgrxJsonApiStore","state$","select","it","map","api","NgrxJsonApiStoreReducer","action","initialNgrxJsonApiState","NgrxJsonApiActionTypes","API_POST_INIT","updatedData","updateStoreDataFromResource","payload","isCreating","API_GET_INIT","query","queries","updateQueryParams","isReading","API_PATCH_INIT","isUpdating","API_DELETE_INIT","updateResourceState","isDeleting","API_POST_SUCCESS","updateStoreDataFromPayload","jsonApiData","API_GET_SUCCESS","updateQueryResults","queryId","API_PATCH_SUCCESS","API_DELETE_SUCCESS","deleteStoreResources","updateQueriesForDeletedResource","API_QUERY_REFRESH","clearQueryResult","API_POST_FAIL","updateResourceErrorsForQuery","API_GET_FAIL","updateQueryErrors","API_PATCH_FAIL","API_DELETE_FAIL","REMOVE_QUERY","removeQuery","LOCAL_QUERY_INIT","MODIFY_STORE_RESOURCE_ERRORS","updateResourceErrors","resourceId","errors","modificationType","LOCAL_QUERY_SUCCESS","PATCH_STORE_RESOURCE","POST_STORE_RESOURCE","NEW_STORE_RESOURCE","DELETE_STORE_RESOURCE","removeStoreResource","API_APPLY_INIT","pending_2","isApplying","pending_3","pendingChange","Error","API_APPLY_SUCCESS","API_APPLY_FAIL","actions","actions_2","API_ROLLBACK","rollbackStoreResources","CLEAR_STORE","COMPACT_STORE","compactStore","apiFactory","http","config","NgrxJsonApi","selectorsFactory","NgrxJsonApiSelectors","serviceFactory","store","selectors","NgrxJsonApiService","configure","provide","useFactory","deps","HttpClient","NGRX_JSON_API_CONFIG","Store","useValue","Direction","ASC","DESC","LOCAL_QUERY_FAIL","ApiApplyInitAction","this","ApiApplySuccessAction","ApiApplyFailAction","ApiPostInitAction","ApiPostSuccessAction","ApiPostFailAction","ApiDeleteInitAction","ApiDeleteSuccessAction","ApiDeleteFailAction","ApiGetInitAction","ApiGetSuccessAction","ApiGetFailAction","ApiRollbackAction","ApiPatchInitAction","ApiPatchSuccessAction","ApiPatchFailAction","DeleteStoreResourceAction","PatchStoreResourceAction","NewStoreResourceAction","PostStoreResourceAction","RemoveQueryAction","LocalQueryInitAction","LocalQuerySuccessAction","LocalQueryFailAction","CompactStoreAction","ClearStoreAction","ApiQueryRefreshAction","ModifyStoreResourceErrorsAction","denormaliseObject","storeData","bag","denormalised","hasOwnProperty","relation","relationDenorm","_.isEqual","_.isPlainObject","relatedRS","getSingleStoreResource","denormaliseStoreResource","relatedRSs","getMultipleStoreResource","r","relationDenormPath","_.set","denormaliseStoreResources","items","results","items_1","item","_.cloneDeep","_.get","resourceIds","resources","getDenormalisedPath","path","baseResourceType","resourceDefinitions","pathSeparator","denormPath","fields","currentResourceType","i","definition","_.find","attributes","resourceRelation","relationType","join","getDenormalisedValue","denormalisedPath","updateResourceObject","original","source","customizer","objValue","srcValue","_.mergeWith","insertStoreResource","storeResources","fromServer","newStoreResources","loading","resourceState","newState_1","isEqualResource","resource0","resource1","meta","links","updateStoreResource","newResource","newResourceState","foundStoreResource","mergedResource","deletedId","queryState","notFoundError","code","status","document","Array","apply","currentErrors","_b","_c","currentErrors_1","currentError","modifiedResources","modifiedResources_1","modifiedResource","_.omit","newQuery","resultIds","override","newStoreData","updatedStoreResources","included","concat","_.reduce","result","storeQueries","newStoreQuery","newStoreQueries","storeQuery","newQueryStore","toResourceIdentifier","getResourceFieldValueFromPath","baseStoreResource","currentStoreResource","relatedPath","filterResources","filteringConfig","_.filter","params","filtering","every","element","filteringOperators","resourceFieldValue","operator","name","comparison","value","_.isString","toLowerCase","_.includes","_.startsWith","_.endsWith","generateIncludedQueryParams","_.isEmpty","generateFieldsQueryParams","generateFilteringQueryParams","f","encodeURIComponent","generateSortingQueryParams","sorting","direction","generateQueryParams","arguments","newParams","p","generatePayload","operation","hasTemporaryId","uuid","lut","toString","d0","Math","random","d1","d2","d3","toKey","collectQueryResults","usedResources","queryName","resultId","collectPendingChanges","collectReferencesForResource","hasChanges","relationshipName","dependencyIds","dependencyIds_1","dependencyId","dependencyKey","collectReferences","sweepUnusedResources","hasDeletions","sortPendingChanges","pendingResources","dependencies","pendingMap","pendingResources_1","pendingResource","key","pendingResources_2","key_1","dependencyIds_2","context","cursor","sorted","visited","visitPending","predecessors","indexOf","JSON","stringify","outgoing","preds","outgoing_1","child","test","prototype","findOne","options","findInternal","findMany","defineProperty","get","_this","_storeSnapshot","let","getNgrxJsonApiStore$","subscribe","putQuery","dispatch","refreshQuery","multi","denormalise","queryResult$","selectManyResults","selectOneResults","finally","getPersistedResourceSnapshot","identifier","snapshot","storeSnapshot","getResourceSnapshot","denormalize","getManyResults$","getOneResult$","selectStoreResource","getStoreResource$","denormaliseResource","storeResource$","combineLatest","getStoreData$","resourceType","patchResource","toRemote","postResource","deleteResource","clear","compact","addResourceErrors","removeResourceErrors","setResourceErrors","SelectStoreResourcePipe","service","transform","decorators","Pipe","args","ctorParameters","DenormaliseStoreResourcePipe","obs","GetDenormalisedValuePipe","headers","HttpHeaders","Content-Type","Accept","definitions","urlBuilder","resourceUrlFor","collectionUrlFor","collectionPathFor","collectionPath","apiUrl","resourcePathFor","resourcePath","find","_generateIncludedQueryParams","_generateFilteringQueryParams","_generateFieldsQueryParams","_generateSortingQueryParams","_generateQueryParams","queryParams","includedParam","filteringParams","sortingParams","fieldsParams","offsetParams","limitParams","undefined","Observable","throw","_.hasIn","limit","offset","requestOptions","method","url","request","create","body","update","delete","newRequestOptions","observe","init","__rest","post","patch","getStoreResourceOfType$","queryStore$","selected$","distinctUntilChanged","getStoreQueries$","getResourceQuery$","getPersistedResource$","NgrxJsonApiEffects","actions$","jsonApi","createResource$","ofType","mergeMap","response","catch","error","of","toErrorPayload","updateResource$","readResource$","takeUntil","localQueryInitEventFor","removeQueryEventFor","deleteResource$","triggerReadOnQueryRefresh$","withLatestFrom","refreshQueriesOnDelete$","needsRefresh","_.findIndex","o","sameIdRequested","flatMap","applyResources$","applyEnabled","ngrxstore","pending_1","payload_1","payload_2","payload_3","concatAll","toArray","toApplyAction","ngOnDestroy","actions_1","contentType","startsWith","String","statusText","Injectable","Actions","propDecorators","Effect","reducer","OpaqueToken","NgrxJsonApiModule","ngModule","providers","NgModule","declarations","imports","EffectsModule","forFeature","StoreModule","exports"],"mappings":"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","file":"./dist/bundles/ngrx-json-api.umd.min.js","sourcesContent":["import * as _ from 'lodash/index';\n\nimport { Actions } from '@ngrx/effects';\n\nimport {\n  Direction,\n  Document,\n  FilteringOperator,\n  FilteringParam,\n  NgrxJsonApiFilteringConfig,\n  NgrxJsonApiStore,\n  NgrxJsonApiStoreData,\n  NgrxJsonApiStoreResources,\n  NgrxJsonApiStoreQueries,\n  OperationType,\n  Payload,\n  Query,\n  Resource,\n  ResourceDefinition,\n  ResourceIdentifier,\n  ResourceError,\n  ResourceState,\n  StoreQuery,\n  SortingParam,\n  StoreResource,\n  ErrorModificationType,\n} from './interfaces';\n\nexport const /** @type {?} */ denormaliseObject = (\n  resource: Resource,\n  storeData: NgrxJsonApiStoreData,\n  bag: NgrxJsonApiStoreData\n): any => {\n  // this function MUST MUTATE resource\n  let /** @type {?} */ denormalised = resource;\n\n  if (resource.hasOwnProperty('relationships')) {\n    Object.keys(resource.relationships).forEach(relation => {\n      resource.relationships[relation]['reference'] = /** @type {?} */(( {} as Resource));\n      let /** @type {?} */ data: ResourceIdentifier | Array<ResourceIdentifier> =\n        resource.relationships[relation].data;\n      // denormalised relation\n      let /** @type {?} */ relationDenorm;\n\n      if (data === null || _.isEqual(data, [])) {\n        relationDenorm = data;\n      } else if (_.isPlainObject(data)) {\n        // hasOne relation\n        let /** @type {?} */ relatedRS = getSingleStoreResource( /** @type {?} */((\n          <ResourceIdentifier>data)),\n          storeData\n        );\n        relationDenorm = denormaliseStoreResource(relatedRS, storeData, bag);\n      } else if (_.isArray(data)) {\n        // hasMany relation\n        let /** @type {?} */ relatedRSs: Array<StoreResource> = getMultipleStoreResource( /** @type {?} */((\n          <ResourceIdentifier[]>data)),\n          storeData\n        );\n        relationDenorm = relatedRSs.map(r =>\n          denormaliseStoreResource(r, storeData, bag)\n        );\n      }\n      let /** @type {?} */ relationDenormPath = 'relationships.' + relation + '.reference';\n      denormalised = /** @type {?} */(( <Resource>_.set(\n        denormalised,\n        relationDenormPath,\n        relationDenorm\n      )));\n    });\n  }\n\n  return denormalised;\n};\n\nexport const /** @type {?} */ denormaliseStoreResources = (\n  items: Array<StoreResource>,\n  storeData: NgrxJsonApiStoreData,\n  bag: any = {}\n): Array<StoreResource> => {\n  let /** @type {?} */ results: Array<StoreResource> = [];\n  for (let /** @type {?} */ item of items) {\n    results.push(denormaliseStoreResource(item, storeData, bag));\n  }\n  return results;\n};\n\nexport const /** @type {?} */ denormaliseStoreResource = (\n  item: StoreResource,\n  storeData: NgrxJsonApiStoreData,\n  bag: any = {}\n): any => {\n  if (!item) {\n    return null;\n  }\n  let /** @type {?} */ storeResource = _.cloneDeep( /** @type {?} */((<StoreResource>item)));\n\n  if (_.isUndefined(bag[storeResource.type])) {\n    bag[storeResource.type] = {};\n  }\n  if (_.isUndefined(bag[storeResource.type][storeResource.id])) {\n    bag[storeResource.type][storeResource.id] = storeResource;\n    storeResource = denormaliseObject(storeResource, storeData, bag);\n    if (storeResource.persistedResource) {\n      storeResource.persistedResource = denormaliseObject(\n        storeResource.persistedResource,\n        storeData,\n        bag\n      );\n    }\n  }\n\n  return bag[storeResource.type][storeResource.id];\n};\n\nexport const /** @type {?} */ getSingleStoreResource = (\n  resourceId: ResourceIdentifier,\n  storeData: NgrxJsonApiStoreData\n): StoreResource => {\n  return _.get(storeData, [resourceId.type, resourceId.id], null);\n};\n\nexport const /** @type {?} */ getMultipleStoreResource = (\n  resourceIds: Array<ResourceIdentifier>,\n  resources: NgrxJsonApiStoreData\n): Array<StoreResource> => {\n  return resourceIds.map(id => getSingleStoreResource(id, resources));\n};\n\nexport const /** @type {?} */ getDenormalisedPath = (\n  path: string,\n  baseResourceType: string,\n  resourceDefinitions: Array<ResourceDefinition>,\n  pathSeparator?: string\n): string => {\n  let /** @type {?} */ denormPath: string[] = [];\n  if (_.isUndefined(pathSeparator)) {\n    pathSeparator = '.';\n  }\n  let /** @type {?} */ fields: Array<string> = path.split(pathSeparator);\n  let /** @type {?} */ currentResourceType = baseResourceType;\n  for (let /** @type {?} */ i = 0; i < fields.length; i++) {\n    let /** @type {?} */ definition = _.find(resourceDefinitions, { type: currentResourceType });\n\n    if (_.isUndefined(definition)) {\n      throw new Error('Definition not found');\n    }\n    // if both attributes and relationships are missing, raise an error\n    if (\n      _.isUndefined(definition.attributes) &&\n      _.isUndefined(definition.relationships)\n    ) {\n      throw new Error('Attributes or Relationships must be provided');\n    }\n\n    if (definition.attributes.hasOwnProperty(fields[i])) {\n      denormPath.push('attributes', fields[i]);\n      break;\n    } else if (definition.relationships.hasOwnProperty(fields[i])) {\n      let /** @type {?} */ resourceRelation = definition.relationships[fields[i]];\n      if (resourceRelation.relationType === 'hasMany') {\n        if (i !== fields.length - 1) {\n          throw new Error('Cannot filter past a hasMany relation');\n        } else {\n          denormPath.push('relationships', fields[i], 'reference');\n        }\n      } else {\n        currentResourceType = resourceRelation.type;\n        denormPath.push('relationships', fields[i], 'reference');\n      }\n    } else {\n      throw new Error('Cannot find field in attributes or relationships');\n    }\n  }\n  return denormPath.join(pathSeparator);\n};\n\nexport const /** @type {?} */ getDenormalisedValue = (\n  path: string,\n  storeResource: StoreResource,\n  resourceDefinitions: Array<ResourceDefinition>,\n  pathSeparator?: string\n) => {\n  let /** @type {?} */ denormalisedPath = getDenormalisedPath(\n    path,\n    storeResource.type,\n    resourceDefinitions,\n    pathSeparator\n  );\n  return _.get(storeResource, denormalisedPath);\n};\n/**\n * Given two objects, it will merge the second in the first.\n * \n */\nexport const updateResourceObject = (\n  original: Resource,\n  source: Resource\n): Resource => {\n  // by default arrays would make use of concat.\n  function customizer(objValue: any, srcValue: any) {\n    if (_.isArray(objValue)) {\n      return srcValue;\n    }\n  }\n\n  return _.mergeWith({}, original, source, customizer);\n};\n/**\n * Insert a StoreResource given the Resource and the StoreResources\n * \n */\nexport const insertStoreResource = (\n  storeResources: NgrxJsonApiStoreResources,\n  resource: Resource,\n  fromServer: boolean\n): NgrxJsonApiStoreResources => {\n  let newStoreResources = { ...storeResources };\n  if (fromServer) {\n    newStoreResources[resource.id] = {\n      ...resource,\n      persistedResource: resource,\n      state: 'IN_SYNC',\n      errors: [],\n      loading: false,\n    } as StoreResource;\n  } else {\n    newStoreResources[resource.id] = {\n      ...resource,\n      persistedResource: null,\n      state: 'CREATED',\n      errors: [],\n      loading: false,\n    } as StoreResource;\n  }\n  return _.isEqual(storeResources, newStoreResources)\n    ? storeResources\n    : newStoreResources;\n};\n/**\n * Removes a StoreResource given the Resource and the StoreResources\n * \n */\nexport const removeStoreResource = (\n  storeData: NgrxJsonApiStoreData,\n  resourceId: ResourceIdentifier\n): NgrxJsonApiStoreData => {\n  if (storeData[resourceId.type][resourceId.id]) {\n    let newState: NgrxJsonApiStoreData = { ...storeData };\n    newState[resourceId.type] = { ...newState[resourceId.type] };\n    delete newState[resourceId.type][resourceId.id];\n    return newState;\n  }\n  return storeData;\n};\n/**\n * Updates the state of a StoreResource in the store.\n * \n * @param storeData\n * @param resourceId\n * @param resourceState\n * @param loading\n */\nexport const updateResourceState = (\n  storeData: NgrxJsonApiStoreData,\n  resourceId: ResourceIdentifier,\n  resourceState?: ResourceState,\n  loading?: OperationType\n): NgrxJsonApiStoreData => {\n  if (\n    _.isUndefined(storeData[resourceId.type]) ||\n    _.isUndefined(storeData[resourceId.type][resourceId.id])\n  ) {\n    if (resourceState === 'DELETED') {\n      let newState: NgrxJsonApiStoreData = { ...storeData };\n      newState[resourceId.type] = { ...newState[resourceId.type] };\n      newState[resourceId.type][resourceId.id] = {\n        ...newState[resourceId.type][resourceId.id],\n      };\n      newState[resourceId.type][resourceId.id] = {\n        type: resourceId.type,\n        id: resourceId.id,\n        persistedResource: null,\n      } as StoreResource;\n      newState[resourceId.type][resourceId.id].state = 'NOT_LOADED';\n      return newState;\n    } else {\n      return storeData;\n    }\n  }\n  let newState: NgrxJsonApiStoreData = { ...storeData };\n  newState[resourceId.type] = { ...newState[resourceId.type] };\n  newState[resourceId.type][resourceId.id] = {\n    ...newState[resourceId.type][resourceId.id],\n  };\n  if (resourceState !== null) {\n    newState[resourceId.type][resourceId.id].state = resourceState;\n  }\n  if (loading != null) {\n    newState[resourceId.type][resourceId.id].loading = loading;\n  }\n  return newState;\n};\n/**\n * Check equality of resource and ignore additional contents used by the\n * store (state, persistedResource, etc.)\n * @param resource0\n * @param resource1\n */\nexport const isEqualResource = (\n  resource0: Resource,\n  resource1: Resource\n): boolean => {\n  if (resource0 === resource1) {\n    return true;\n  }\n  if (resource0 !== null !== (resource1 !== null)) {\n    return false;\n  }\n\n  return (\n    _.isEqual(resource0.id, resource1.id) &&\n    _.isEqual(resource0.type, resource1.type) &&\n    _.isEqual(resource0.attributes, resource1.attributes) &&\n    _.isEqual(resource0.meta, resource1.meta) &&\n    _.isEqual(resource0.links, resource1.links) &&\n    _.isEqual(resource0.relationships, resource1.relationships)\n  );\n};\n\nexport const /** @type {?} */ updateStoreResource = (\n  state: NgrxJsonApiStoreResources,\n  resource: Resource,\n  fromServer: boolean\n): NgrxJsonApiStoreResources => {\n  let /** @type {?} */ foundStoreResource = state[resource.id];\n  let /** @type {?} */ persistedResource = state[resource.id].persistedResource;\n\n  let /** @type {?} */ newResource: Resource;\n  let /** @type {?} */ newResourceState: ResourceState;\n  if (fromServer) {\n    // form server, override everything\n    // TODO need to handle check and keep local updates?\n    newResource = resource;\n    persistedResource = resource;\n    newResourceState = 'IN_SYNC';\n  } else {\n    let /** @type {?} */ mergedResource = updateResourceObject(foundStoreResource, resource);\n    if (isEqualResource(mergedResource, persistedResource)) {\n      // no changes anymore, do nothing\n      newResource = persistedResource;\n      newResourceState = 'IN_SYNC';\n    } else {\n      // merge changes and mark as CREATED or UPDATED depending on whether\n      // an original version is available\n      newResource = mergedResource;\n      if (persistedResource !== null) {\n        newResourceState = 'UPDATED';\n      } else if (foundStoreResource.state === 'NEW') {\n        newResourceState = 'NEW';\n      } else {\n        newResourceState = 'CREATED';\n      }\n    }\n  }\n\n  let /** @type {?} */ newState = { ...state };\n  newState[resource.id] = /** @type {?} */(( {\n    ...newResource,\n    persistedResource: persistedResource,\n    state: newResourceState,\n    errors: [],\n    loading: false,\n  } as StoreResource));\n\n  return _.isEqual(newState[resource.id], state[resource.id])\n    ? state\n    : newState;\n};\n\nexport const /** @type {?} */ updateQueriesForDeletedResource = (\n  state: NgrxJsonApiStoreQueries,\n  deletedId: ResourceIdentifier\n): NgrxJsonApiStoreQueries => {\n  let /** @type {?} */ newState: NgrxJsonApiStoreQueries = state;\n  for (let /** @type {?} */ queryId in state) {\n    if (state.hasOwnProperty(queryId)) {\n      let /** @type {?} */ queryState = state[queryId];\n      if (\n        queryState.query.id === deletedId.id &&\n        queryState.query.type === deletedId.type\n      ) {\n        // found a query for a resource that was deleted => modify to 404\n        newState = clearQueryResult(newState, queryState.query.queryId);\n        let /** @type {?} */ notFoundError: ResourceError = { code: '404', status: 'Not Found' };\n        newState[queryState.query.queryId].errors = [notFoundError];\n      }\n    }\n  }\n  return newState;\n};\n\nexport const /** @type {?} */ updateResourceErrorsForQuery = (\n  storeData: NgrxJsonApiStoreData,\n  query: Query,\n  document: Document\n): NgrxJsonApiStoreData => {\n  if (!query.type || !query.id || document.data instanceof Array) {\n    throw new Error('invalid parameters');\n  }\n  return updateResourceErrors(\n    storeData,\n    { id: query.id, type: query.type },\n    document.errors,\n    'SET'\n  );\n};\n\nexport const /** @type {?} */ updateResourceErrors = (\n  storeData: NgrxJsonApiStoreData,\n  id: ResourceIdentifier,\n  errors: Array<ResourceError>,\n  modificationType: ErrorModificationType\n): NgrxJsonApiStoreData => {\n  if (!storeData[id.type] || !storeData[id.type][id.id]) {\n    return storeData;\n  }\n  let /** @type {?} */ newState: NgrxJsonApiStoreData = { ...storeData };\n  newState[id.type] = { ...newState[id.type] };\n  let /** @type {?} */ storeResource = { ...newState[id.type][id.id] };\n\n  if (modificationType === 'SET') {\n    storeResource.errors = [];\n    if (errors) {\n      storeResource.errors.push(...errors);\n    }\n  } else if (modificationType === 'ADD') {\n    let /** @type {?} */ currentErrors = storeResource.errors;\n    storeResource.errors = [];\n    if (currentErrors) {\n      storeResource.errors.push(...currentErrors);\n    }\n    if (errors) {\n      storeResource.errors.push(...errors);\n    }\n  } else {\n    let /** @type {?} */ currentErrors = storeResource.errors;\n    storeResource.errors = [];\n    if (currentErrors) {\n      for (let /** @type {?} */ currentError of currentErrors) {\n        let /** @type {?} */ remove =\n          errors && errors.filter(it => _.isEqual(it, currentError)).length > 0;\n        if (!remove) {\n          storeResource.errors.push(currentError);\n        }\n      }\n    }\n  }\n  newState[id.type][id.id] = storeResource;\n  return newState;\n};\n/**\n * @param {?} newState\n * @param {?} type\n * @param {?} id\n * @return {?}\n */\nfunction rollbackResource(\n  newState: NgrxJsonApiStoreData,\n  type: string,\n  id: string\n) {\n  let /** @type {?} */ storeResource = newState[type][id];\n  if (!storeResource.persistedResource) {\n    delete newState[type][id];\n  } else if (storeResource.state !== 'IN_SYNC') {\n    newState[type][id] = /** @type {?} */(( <StoreResource>{\n      ...newState[type][id],\n      state: 'IN_SYNC',\n      resource: newState[type][id].persistedResource,\n    }));\n  }\n}\n\nexport const /** @type {?} */ rollbackStoreResources = (\n  storeData: NgrxJsonApiStoreData,\n  ids: Array<ResourceIdentifier>,\n  include: Array<string>\n): NgrxJsonApiStoreData => {\n  let /** @type {?} */ newState: NgrxJsonApiStoreData = { ...storeData };\n\n  if (_.isUndefined(ids)) {\n    Object.keys(newState).forEach(type => {\n      newState[type] = { ...newState[type] };\n      Object.keys(newState[type]).forEach(id => {\n        rollbackResource(newState, type, id);\n      });\n    });\n  } else {\n    let /** @type {?} */ modifiedResources = getPendingChanges(newState, ids, include, true);\n    for (let /** @type {?} */ modifiedResource of modifiedResources) {\n      rollbackResource(newState, modifiedResource.type, modifiedResource.id);\n    }\n  }\n  return newState;\n};\n\nexport const /** @type {?} */ deleteStoreResources = (\n  storeData: NgrxJsonApiStoreData,\n  query: Query\n) => {\n  let /** @type {?} */ newState = { ...storeData };\n  // if an id is not provided, all resources of the provided type will be deleted\n  if (typeof query.id === 'undefined') {\n    newState[query.type] = {};\n  } else {\n    newState[query.type] = /** @type {?} */(( _.omit(newState[query.type], [\n      query.id,\n    ]) as NgrxJsonApiStoreResources));\n  }\n  return newState;\n};\n\nexport const /** @type {?} */ clearQueryResult = (\n  storeData: NgrxJsonApiStoreQueries,\n  queryId: string\n) => {\n  let /** @type {?} */ newQuery = { ...storeData[queryId] };\n  delete newQuery.resultIds;\n  delete newQuery.errors;\n  delete newQuery.meta;\n  delete newQuery.links;\n\n  let /** @type {?} */ newState = { ...storeData };\n  newState[queryId] = newQuery;\n  return newState;\n};\n/**\n * Updates a given storeData by either inserting a resource or updating\n * an existing resource.\n * \n * @param storeData\n * @param resource\n * @param fromServer\n * @param override \n * \n * @return a new NgrxJsonApiStoreData with an inserted/updated resource.\n */\nexport const updateStoreDataFromResource = (\n  storeData: NgrxJsonApiStoreData,\n  resource: Resource,\n  fromServer: boolean,\n  override: boolean\n): NgrxJsonApiStoreData => {\n  if (_.isUndefined(storeData[resource.type])) {\n    let newStoreData: NgrxJsonApiStoreData = { ...storeData };\n    newStoreData[resource.type] = {};\n    newStoreData[resource.type] = insertStoreResource(\n      newStoreData[resource.type],\n      resource,\n      fromServer\n    );\n    return newStoreData;\n  } else if (_.isUndefined(storeData[resource.type][resource.id]) || override) {\n    let updatedStoreResources = insertStoreResource(\n      storeData[resource.type],\n      resource,\n      fromServer\n    );\n\n    // check if nothing has changed\n    if (updatedStoreResources !== storeData[resource.type]) {\n      let newStoreData: NgrxJsonApiStoreData = { ...storeData };\n      newStoreData[resource.type] = updatedStoreResources;\n      return newStoreData;\n    }\n    return storeData;\n  } else {\n    let updatedStoreResources = updateStoreResource(\n      storeData[resource.type],\n      resource,\n      fromServer\n    );\n\n    // check if nothing has changed\n    if (updatedStoreResources !== storeData[resource.type]) {\n      let newStoreData: NgrxJsonApiStoreData = { ...storeData };\n      newStoreData[resource.type] = updatedStoreResources;\n      return newStoreData;\n    }\n    return storeData;\n  }\n};\n\nexport const /** @type {?} */ updateStoreDataFromPayload = (\n  storeData: NgrxJsonApiStoreData,\n  payload: Document\n): NgrxJsonApiStoreData => {\n  let /** @type {?} */ data = /** @type {?} */(( <Array<Resource> | Resource>_.get(payload, 'data')));\n\n  if (_.isUndefined(data)) {\n    return storeData;\n  }\n\n  data = _.isArray(data) ? /** @type {?} */(( <Resource[]>data)) : /** @type {?} */(( <Resource[]>[data]));\n\n  let /** @type {?} */ included = /** @type {?} */(( <Array<Resource>>_.get(payload, 'included')));\n\n  if (!_.isUndefined(included)) {\n    data = [...data, ...included];\n  }\n\n  return /** @type {?} */(( <NgrxJsonApiStoreData>_.reduce(\n    data,\n    (result: NgrxJsonApiStoreData, resource: Resource) => {\n      // let resourcePath: string = getResourcePath(\n      //   result.resourcesDefinitions, resource.type);\n      // Extremely ugly, needs refactoring!\n      // let newPartialState = { data: {} };\n      // newPartialState.data[resourcePath] = { data: {} } ;\n      // newPartialState.data = updateOrInsertResource(\n      // result.data, resource);\n      return updateStoreDataFromResource(result, resource, true, true);\n      // result.data[resourcePath].data = updateOrInsertResource(\n      // result.data[resourcePath].data, resource);\n      // return <NgrxJsonApiStore>_.merge({}, result, newPartialState);\n    },\n    storeData\n  )));\n};\n/**\n * Updates the storeQueries by either adding a new ResourceQueryStore\n * or modifying an existing one.\n * \n * @param storeQueries\n * @param query \n * \n * @return a new NgrxJsonApiStoreQueries with the inserted/modified\n * ResourceQueryStore\n */\nexport const updateQueryParams = (\n  storeQueries: NgrxJsonApiStoreQueries,\n  query: Query\n): NgrxJsonApiStoreQueries => {\n  if (!query.queryId) {\n    return storeQueries;\n  }\n\n  let newStoreQuery = { ...storeQueries[query.queryId] };\n  newStoreQuery.loading = true;\n  newStoreQuery.query = _.cloneDeep(query);\n\n  if (_.isUndefined(newStoreQuery.errors)) {\n    newStoreQuery.errors = [];\n  }\n\n  let newStoreQueries: NgrxJsonApiStoreQueries = { ...storeQueries };\n  newStoreQueries[newStoreQuery.query.queryId] = newStoreQuery;\n  return newStoreQueries;\n};\n/**\n * Updates the query results for given a queryId and the results.\n */\nexport const updateQueryResults = (\n  storeQueries: NgrxJsonApiStoreQueries,\n  queryId: string,\n  document: Document\n): NgrxJsonApiStoreQueries => {\n  let storeQuery: StoreQuery = storeQueries[queryId];\n  if (storeQuery) {\n    let data = _.isArray(document.data) ? document.data : [document.data];\n    let newQueryStore = {\n      ...storeQuery,\n      resultIds: data.map(it => (it ? toResourceIdentifier(it) : [])),\n      meta: document.meta,\n      links: document.links,\n      loading: false,\n    };\n\n    let newState: NgrxJsonApiStoreQueries = { ...storeQueries };\n    newState[queryId] = <StoreQuery>newQueryStore;\n    return newState;\n  }\n  return storeQueries;\n};\n/**\n * Update the query errors given the queryId and a storeQueries and the\n * document containing the error\n * \n * \n */\nexport const updateQueryErrors = (\n  storeQueries: NgrxJsonApiStoreQueries,\n  queryId: string,\n  document: Document\n): NgrxJsonApiStoreQueries => {\n  if (!queryId || !storeQueries[queryId]) {\n    return storeQueries;\n  }\n  let newState = { ...storeQueries };\n  let newStoreQuery = { ...newState[queryId] };\n  newStoreQuery.errors = [];\n  if (document.errors) {\n    newStoreQuery.errors.push(...document.errors);\n  }\n  newState[queryId] = newStoreQuery;\n  return newState;\n};\n/**\n * Removes a query given its queryId from the NgrxJsonApiStoreQueries.\n */\nexport const removeQuery = (\n  storeQueries: NgrxJsonApiStoreQueries,\n  queryId: string\n): NgrxJsonApiStoreQueries => {\n  let newState: NgrxJsonApiStoreQueries = { ...storeQueries };\n  delete newState[queryId];\n  return newState;\n};\n/**\n * Given a resource, it will return an object containing the resource id and type.\n */\nexport const toResourceIdentifier = (\n  resource: Resource\n): ResourceIdentifier => {\n  return { type: resource.type, id: resource.id };\n};\n/**\n * Get the value for the last field in a given fitering path.\n * \n * @param path\n * @param baseStoreResource\n * @param storeData\n * @param resourceDefinitions\n * @param pathSepartor\n * @return the value of the last field in the path.\n */\nexport const getResourceFieldValueFromPath = (\n  path: string,\n  baseStoreResource: StoreResource,\n  storeData: NgrxJsonApiStoreData,\n  resourceDefinitions: Array<ResourceDefinition>,\n  pathSeparator?: string\n) => {\n  if (_.isUndefined(pathSeparator)) {\n    pathSeparator = '.';\n  }\n  let fields: Array<string> = path.split(pathSeparator);\n  let currentStoreResource = baseStoreResource;\n  for (let i = 0; i < fields.length; i++) {\n    let definition = _.find(resourceDefinitions, {\n      type: currentStoreResource.type,\n    });\n\n    if (_.isUndefined(definition)) {\n      throw new Error('Definition not found');\n    }\n    // if both attributes and relationships are missing, raise an error\n    if (\n      _.isUndefined(definition.attributes) &&\n      _.isUndefined(definition.relationships)\n    ) {\n      throw new Error('Attributes or Relationships must be provided');\n    }\n    if (definition.attributes.hasOwnProperty(fields[i])) {\n      return _.get(currentStoreResource, 'attributes.' + fields[i], null);\n    } else if (definition.relationships.hasOwnProperty(fields[i])) {\n      if (i === fields.length - 1) {\n        throw new Error(\n          'The last field in the filtering path cannot be a relation'\n        );\n      }\n      let resourceRelation = definition.relationships[fields[i]];\n      if (resourceRelation.relationType === 'hasMany') {\n        throw new Error('Cannot filter past a hasMany relation');\n      } else {\n        let relation = _.get(\n          currentStoreResource,\n          'relationships.' + fields[i],\n          null\n        );\n        if (!relation || !relation.data) {\n          return null;\n        } else {\n          let relatedPath = [resourceRelation.type, relation.data.id];\n          currentStoreResource = <StoreResource>_.get(storeData, relatedPath);\n        }\n      }\n    } else {\n      throw new Error('Cannot find field in attributes or relationships');\n    }\n    if (_.isUndefined(currentStoreResource)) {\n      return null;\n    }\n  }\n};\n\nexport const /** @type {?} */ filterResources = (\n  resources: NgrxJsonApiStoreResources,\n  storeData: NgrxJsonApiStoreData,\n  query: Query,\n  resourceDefinitions: Array<ResourceDefinition>,\n  filteringConfig?: NgrxJsonApiFilteringConfig\n) => {\n  return _.filter(resources, resource => {\n    if (\n      query.hasOwnProperty('params') &&\n      query.params.hasOwnProperty('filtering')\n    ) {\n      return query.params.filtering.every(element => {\n        let /** @type {?} */ pathSeparator;\n        let /** @type {?} */ filteringOperators;\n\n        if (!_.isUndefined(filteringConfig)) {\n          pathSeparator = /** @type {?} */(( <string>_.get(filteringConfig, 'pathSeparator')));\n          filteringOperators = /** @type {?} */(( <Array<FilteringOperator>>_.get(\n            filteringConfig,\n            'filteringOperators'\n          )));\n        }\n        // resource type and attribute\n        let /** @type {?} */ resourceFieldValue = getResourceFieldValueFromPath(\n          element.path,\n          resource,\n          storeData,\n          resourceDefinitions,\n          pathSeparator\n        );\n        if (!resourceFieldValue) {\n          return false;\n        }\n\n        let /** @type {?} */ operator = /** @type {?} */(( <FilteringOperator>_.find(filteringOperators, {\n          name: element.operator,\n        })));\n\n        if (operator) {\n          return operator.comparison(element.value, resourceFieldValue);\n        }\n\n        element.operator = element.hasOwnProperty('operator')\n          ? element.operator\n          : 'iexact';\n\n        switch (element.operator) {\n          case 'iexact':\n            if (_.isString(element.value) && _.isString(resourceFieldValue)) {\n              return (\n                element.value.toLowerCase() === resourceFieldValue.toLowerCase()\n              );\n            } else {\n              return element.value === resourceFieldValue;\n            }\n\n          case 'exact':\n            return element.value === resourceFieldValue;\n\n          case 'contains':\n            return _.includes(resourceFieldValue, element.value);\n\n          case 'icontains':\n            return _.includes(\n              resourceFieldValue.toLowerCase(),\n              element.value.toLowerCase()\n            );\n\n          case 'in':\n            if (_.isArray(element.value)) {\n              return _.includes(element.value, resourceFieldValue);\n            } else {\n              return _.includes([element.value], resourceFieldValue);\n            }\n          case 'gt':\n            return element.value > resourceFieldValue;\n\n          case 'gte':\n            return element.value >= resourceFieldValue;\n\n          case 'lt':\n            return element.value < resourceFieldValue;\n\n          case 'lte':\n            return element.value <= resourceFieldValue;\n\n          case 'startswith':\n            return _.startsWith(resourceFieldValue, element.value);\n\n          case 'istartswith':\n            return _.startsWith(\n              resourceFieldValue.toLowerCase(),\n              element.value.toLowerCase()\n            );\n\n          case 'endswith':\n            return _.endsWith(resourceFieldValue, element.value);\n\n          case 'iendswith':\n            return _.endsWith(\n              resourceFieldValue.toLowerCase(),\n              element.value.toLowerCase()\n            );\n\n          default:\n            return true;\n        }\n      });\n    } else {\n      return true;\n    }\n  });\n};\n\nexport const /** @type {?} */ generateIncludedQueryParams = (\n  included: Array<string>\n): string => {\n  if (_.isEmpty(included)) {\n    return '';\n  }\n\n  return 'include=' + included.join();\n};\n\nexport const /** @type {?} */ generateFieldsQueryParams = (fields: Array<string>): string => {\n  if (_.isEmpty(fields)) {\n    return '';\n  }\n\n  return 'fields=' + fields.join();\n};\n\nexport const /** @type {?} */ generateFilteringQueryParams = (\n  filtering: Array<FilteringParam>\n): string => {\n  if (_.isEmpty(filtering)) {\n    return '';\n  }\n  let /** @type {?} */ filteringParams = filtering.map(f => {\n    return (\n      'filter[' +\n      f.path +\n      ']' +\n      (f.operator ? '[' + f.operator + ']' : '') +\n      '=' +\n      encodeURIComponent(f.value)\n    );\n  });\n  return filteringParams.join('&');\n};\n\nexport const /** @type {?} */ generateSortingQueryParams = (\n  sorting: Array<SortingParam>\n): string => {\n  if (_.isEmpty(sorting)) {\n    return '';\n  }\n  return (\n    'sort=' +\n    sorting\n      .map(f => (f.direction === Direction.ASC ? '' : '-') + f.api)\n      .join(',')\n  );\n};\n\nexport const /** @type {?} */ generateQueryParams = (...params: Array<string>) => {\n  let /** @type {?} */ newParams = params.filter(p => p !== '');\n  if (newParams.length !== 0) {\n    return '?' + newParams.join('&');\n  } else {\n    return '';\n  }\n};\n\nexport const /** @type {?} */ generatePayload = (\n  resource: StoreResource,\n  operation: OperationType\n): Payload => {\n  let /** @type {?} */ payload: Payload = {\n    query: {\n      type: resource.type,\n    },\n  };\n\n  // the data to be updated or created\n  if (operation === 'POST' || operation === 'PATCH') {\n    payload.jsonApiData = {\n      data: {\n        id: resource.id,\n        type: resource.type,\n        attributes: resource.attributes,\n        relationships: resource.relationships,\n      },\n    };\n  }\n\n  if (operation === 'POST' && resource.hasTemporaryId) {\n    delete payload.jsonApiData.data.id;\n  }\n\n  // 'DELETE' only needs a query and it also needs an id in its query\n  // 'PATCH' also needs an id in its query\n  // 'POST' needed locally to allow to write back errors to store if id is available\n  if (operation === 'PATCH' || operation === 'DELETE' || operation === 'POST') {\n    payload.query.id = resource.id;\n  }\n\n  return payload;\n};\n\n/* tslint:disable */\nexport const /** @type {?} */ uuid = () => {\n  let /** @type {?} */ lut = [];\n  for (let /** @type {?} */ i = 0; i < 256; i++) {\n    lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n  }\n  let /** @type {?} */ d0 = (Math.random() * 0xffffffff) | 0;\n  let /** @type {?} */ d1 = (Math.random() * 0xffffffff) | 0;\n  let /** @type {?} */ d2 = (Math.random() * 0xffffffff) | 0;\n  let /** @type {?} */ d3 = (Math.random() * 0xffffffff) | 0;\n  return (\n    lut[d0 & 0xff] +\n    lut[(d0 >> 8) & 0xff] +\n    lut[(d0 >> 16) & 0xff] +\n    lut[(d0 >> 24) & 0xff] +\n    '-' +\n    lut[d1 & 0xff] +\n    lut[(d1 >> 8) & 0xff] +\n    '-' +\n    lut[((d1 >> 16) & 0x0f) | 0x40] +\n    lut[(d1 >> 24) & 0xff] +\n    '-' +\n    lut[(d2 & 0x3f) | 0x80] +\n    lut[(d2 >> 8) & 0xff] +\n    '-' +\n    lut[(d2 >> 16) & 0xff] +\n    lut[(d2 >> 24) & 0xff] +\n    lut[d3 & 0xff] +\n    lut[(d3 >> 8) & 0xff] +\n    lut[(d3 >> 16) & 0xff] +\n    lut[(d3 >> 24) & 0xff]\n  );\n};\n/* tslint:enable */\n\nconst /** @type {?} */ toKey = (id: ResourceIdentifier) => {\n  return id.id + '@' + id.type;\n};\n\nconst /** @type {?} */ collectQueryResults = (state: NgrxJsonApiStore, usedResources: any) => {\n  for (let /** @type {?} */ queryName in state.queries) {\n    if (state.queries.hasOwnProperty(queryName)) {\n      let /** @type {?} */ query = state.queries[queryName];\n      if (query.resultIds) {\n        for (let /** @type {?} */ resultId of query.resultIds) {\n          usedResources[toKey(resultId)] = true;\n        }\n      }\n    }\n  }\n};\n\nconst /** @type {?} */ collectPendingChanges = (state: NgrxJsonApiStore, usedResources: any) => {\n  for (let /** @type {?} */ type in state.data) {\n    if (state.data.hasOwnProperty(type)) {\n      let /** @type {?} */ resources = state.data[type];\n      for (let /** @type {?} */ id in resources) {\n        if (resources.hasOwnProperty(id)) {\n          let /** @type {?} */ resource = resources[id];\n          if (resource.state !== 'IN_SYNC') {\n            usedResources[toKey(resource)] = true;\n          }\n        }\n      }\n    }\n  }\n};\n\nconst /** @type {?} */ collectReferencesForResource = (\n  state: NgrxJsonApiStore,\n  usedResources: any,\n  resource: Resource\n) => {\n  let /** @type {?} */ hasChanges: boolean;\n  for (let /** @type {?} */ relationshipName in resource.relationships) {\n    if (resource.relationships.hasOwnProperty(relationshipName)) {\n      let /** @type {?} */ data = resource.relationships[relationshipName].data;\n      if (data) {\n        let /** @type {?} */ dependencyIds: Array<ResourceIdentifier> =\n          data instanceof Array ? data : [data];\n        for (let /** @type {?} */ dependencyId of dependencyIds) {\n          let /** @type {?} */ dependencyKey = toKey(dependencyId);\n          if (!usedResources[dependencyKey]) {\n            // change found, an other iteration will be necssary to detect\n            // transitive dependencies\n            hasChanges = true;\n            usedResources[dependencyKey] = true;\n          }\n        }\n      }\n    }\n  }\n  return hasChanges;\n};\n\nconst /** @type {?} */ collectReferences = (state: NgrxJsonApiStore, usedResources: any) => {\n  while (true) {\n    let /** @type {?} */ hasChanges = false;\n    for (let /** @type {?} */ type in state.data) {\n      if (state.data.hasOwnProperty(type)) {\n        let /** @type {?} */ resources = state.data[type];\n        for (let /** @type {?} */ id in resources) {\n          if (resources.hasOwnProperty(id)) {\n            let /** @type {?} */ resource = resources[id];\n            if (usedResources[toKey(resource)]) {\n              // in use, do not collect its relations\n              hasChanges =\n                hasChanges ||\n                collectReferencesForResource(state, usedResources, resource);\n            }\n          }\n        }\n      }\n    }\n    if (!hasChanges) {\n      break;\n    }\n  }\n};\n\nconst /** @type {?} */ sweepUnusedResources = (state: NgrxJsonApiStore, usedResources: any) => {\n  let /** @type {?} */ hasDeletions = false;\n  let /** @type {?} */ newState = _.cloneDeep(state);\n  for (let /** @type {?} */ type in newState.data) {\n    if (newState.data.hasOwnProperty(type)) {\n      let /** @type {?} */ resources = newState.data[type];\n      for (let /** @type {?} */ id in resources) {\n        if (resources.hasOwnProperty(id)) {\n          let /** @type {?} */ resource = resources[id];\n          if (!usedResources[toKey(resource)]) {\n            hasDeletions = true;\n            delete resources[id];\n          }\n        }\n      }\n\n      if (_.isEmpty(resources)) {\n        delete newState.data[type];\n      }\n    }\n  }\n  return hasDeletions ? newState : state;\n};\n\nexport const /** @type {?} */ compactStore = (state: NgrxJsonApiStore) => {\n  let /** @type {?} */ usedResources = {};\n\n  // query results can not be collected\n  collectQueryResults(state, usedResources);\n\n  // pending changes cannot be collected\n  collectPendingChanges(state, usedResources);\n\n  // references from non-collected objects cannot be collected as well\n  collectReferences(state, usedResources);\n\n  // remove everything that is not collected\n  return sweepUnusedResources(state, usedResources);\n};\n\ninterface TopologySortContext {\n  pendingResources: Array<StoreResource>;\n  cursor: number;\n  sorted: Array<StoreResource>;\n  visited: Array<boolean>;\n  dependencies: { [id: string]: Array<StoreResource> };\n}\n\nexport const /** @type {?} */ sortPendingChanges = (\n  pendingResources: Array<StoreResource>\n): Array<StoreResource> => {\n  // allocate dependency\n  let /** @type {?} */ dependencies: any = {};\n  let /** @type {?} */ pendingMap: any = {};\n  for (let /** @type {?} */ pendingResource of pendingResources) {\n    let /** @type {?} */ resource = pendingResource;\n    let /** @type {?} */ key = toKey(resource);\n    dependencies[key] = [];\n    pendingMap[key] = pendingResource;\n  }\n\n  // extract dependencies\n  for (let /** @type {?} */ pendingResource of pendingResources) {\n    let /** @type {?} */ resource = pendingResource;\n    if (resource.relationships) {\n      let /** @type {?} */ key = toKey(resource);\n      Object.keys(resource.relationships).forEach(relationshipName => {\n        let /** @type {?} */ data = resource.relationships[relationshipName].data;\n        if (data) {\n          let /** @type {?} */ dependencyIds: Array<ResourceIdentifier> =\n            data instanceof Array ? data : [data];\n          for (let /** @type {?} */ dependencyId of dependencyIds) {\n            let /** @type {?} */ dependencyKey = toKey(dependencyId);\n            if (\n              pendingMap[dependencyKey] &&\n              pendingMap[dependencyKey].state === 'CREATED'\n            ) {\n              // we have a dependency between two unsaved objects\n              dependencies[key].push(pendingMap[dependencyKey]);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  // order\n  let /** @type {?} */ context = {\n    pendingResources: pendingResources,\n    cursor: pendingResources.length,\n    sorted: new Array(pendingResources.length),\n    dependencies: dependencies,\n    visited: /** @type {?} */(( <any[]>[])),\n  };\n\n  let /** @type {?} */ i = context.cursor;\n  while (i--) {\n    if (!context.visited[i]) {\n      visitPending(pendingResources[i], i, [], context);\n    }\n  }\n\n  return context.sorted;\n};\n\nconst /** @type {?} */ visitPending = (\n  pendingResource: StoreResource,\n  i: any,\n  predecessors: any,\n  context: TopologySortContext\n) => {\n  let /** @type {?} */ key = toKey(pendingResource);\n  if (predecessors.indexOf(key) >= 0) {\n    throw new Error(\n      'Cyclic dependency: ' + key + ' with ' + JSON.stringify(predecessors)\n    );\n  }\n\n  if (context.visited[i]) {\n    return;\n  }\n  context.visited[i] = true;\n\n  // outgoing edges\n  let /** @type {?} */ outgoing: Array<StoreResource> = context.dependencies[key];\n\n  let /** @type {?} */ preds = predecessors.concat(key);\n  for (let /** @type {?} */ child of outgoing) {\n    visitPending(\n      child,\n      context.pendingResources.indexOf(child),\n      preds,\n      context\n    );\n  }\n\n  context.sorted[--context.cursor] = pendingResource;\n};\n/**\n * @param {?} state\n * @param {?} pending\n * @param {?} id\n * @param {?} include\n * @param {?} includeNew\n * @return {?}\n */\nfunction collectPendingChange(\n  state: NgrxJsonApiStoreData,\n  pending: Array<StoreResource>,\n  id: ResourceIdentifier,\n  include: Array<Array<string>>,\n  includeNew: boolean\n) {\n  let /** @type {?} */ storeResource = state[id.type][id.id];\n  if (\n    storeResource.state !== 'IN_SYNC' &&\n    (storeResource.state !== 'NEW' || includeNew)\n  ) {\n    pending.push(storeResource);\n  }\n\n  for (let /** @type {?} */ includeElement of include) {\n    if (includeElement.length > 0) {\n      let /** @type {?} */ relationshipName = includeElement[0];\n      if (\n        storeResource.relationships &&\n        storeResource.relationships[relationshipName]\n      ) {\n        let /** @type {?} */ data = storeResource.relationships[relationshipName].data;\n        if (data) {\n          let /** @type {?} */ relationInclude: Array<Array<string>> = [];\n          include\n            .filter(\n              relIncludeElem =>\n                relIncludeElem.length >= 2 &&\n                relIncludeElem[0] == relationshipName\n            )\n            .forEach(relIncludeElem =>\n              relationInclude.push(relIncludeElem.slice(1))\n            );\n\n          if (_.isArray(data)) {\n            let /** @type {?} */ relationIds = /** @type {?} */(( data as Array<ResourceIdentifier>));\n            relationIds.forEach(relationId =>\n              collectPendingChange(\n                state,\n                pending,\n                relationId,\n                relationInclude,\n                includeNew\n              )\n            );\n          } else {\n            let /** @type {?} */ relationId = /** @type {?} */(( data as ResourceIdentifier));\n            collectPendingChange(\n              state,\n              pending,\n              relationId,\n              relationInclude,\n              includeNew\n            );\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * @param {?} state\n * @param {?} ids\n * @param {?} include\n * @param {?=} includeNew\n * @return {?}\n */\nexport function getPendingChanges(\n  state: NgrxJsonApiStoreData,\n  ids: Array<ResourceIdentifier>,\n  include: Array<string>,\n  includeNew?: boolean\n): Array<StoreResource> {\n  let /** @type {?} */ pending: Array<StoreResource> = [];\n\n  if (_.isUndefined(ids)) {\n    // check all\n    Object.keys(state).forEach(type => {\n      Object.keys(state[type]).forEach(id => {\n        let /** @type {?} */ storeResource = state[type][id];\n        if (\n          storeResource.state !== 'IN_SYNC' &&\n          (storeResource.state !== 'NEW' || includeNew)\n        ) {\n          pending.push(storeResource);\n        }\n      });\n    });\n  } else {\n    let /** @type {?} */ relationshipInclusions = [];\n    if (include) {\n      for (let /** @type {?} */ includeElement of include) {\n        relationshipInclusions.push(includeElement.split('.'));\n      }\n    }\n    for (let /** @type {?} */ id of ids) {\n      collectPendingChange(\n        state,\n        pending,\n        id,\n        relationshipInclusions,\n        includeNew\n      );\n    }\n    pending = _.uniqBy(pending, function(e) {\n      return e.type + '####' + e.id;\n    });\n  }\n\n  return pending;\n}\n","import * as _ from 'lodash/index';\n\nimport { Observable } from 'rxjs/Observable';\nimport { ErrorObservable } from 'rxjs/observable/ErrorObservable';\nimport'rxjs/add/observable/concat';\nimport'rxjs/add/observable/throw';\nimport'rxjs/add/operator/combineLatest';\nimport'rxjs/add/operator/concat';\nimport'rxjs/add/operator/concatMap';\nimport'rxjs/add/operator/distinctUntilChanged';\nimport'rxjs/add/operator/do';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/let';\nimport'rxjs/add/operator/map';\nimport'rxjs/add/operator/mergeMap';\nimport'rxjs/add/observable/zip';\n\nimport { Store } from '@ngrx/store';\n\nimport {\n  NgrxJsonApiConfig,\n  NgrxJsonApiStore,\n  NgrxJsonApiStoreData,\n  NgrxJsonApiStoreResources,\n  NgrxJsonApiStoreQueries,\n  Resource,\n  ResourceIdentifier,\n  ResourceError,\n  Query,\n  StoreResource,\n  ManyQueryResult,\n  OneQueryResult,\n  StoreQuery,\n} from './interfaces';\nimport {\n  filterResources,\n  denormaliseStoreResource,\n  denormaliseStoreResources,\n} from './utils';\n/**\n * @param {?} state$\n * @return {?}\n */\nexport function getNgrxJsonApiStore(state$: Store<any>): Observable<NgrxJsonApiStore>{\n  return state$.select('NgrxJsonApi').filter(it => !_.isUndefined(it)).map(it => it.api);\n}\nexport class NgrxJsonApiSelectors {\n/**\n * @param {?} config\n */\nconstructor(public config: NgrxJsonApiConfig) {}\n/**\n * @return {?}\n */\npublic getNgrxJsonApiStore$(): (\n    state$: Store<any>\n  ) => Observable<NgrxJsonApiStore> {\n    return (state$: Store<any>): Observable<NgrxJsonApiStore> => {\n      // note that upon setup the store may not yet be initialized\n      return state$.select('NgrxJsonApi').filter(it => !_.isUndefined(it)).map(it => it.api);\n    };\n  }\n/**\n * @return {?}\n */\npublic getStoreData$(): (\n    state$: Store<NgrxJsonApiStore>\n  ) => Observable<NgrxJsonApiStoreData> {\n    return (\n      state$: Store<NgrxJsonApiStore>\n    ): Observable<NgrxJsonApiStoreData> => {\n      return state$.select('data');\n    };\n  }\n/**\n * @param {?} type\n * @return {?}\n */\npublic getStoreResourceOfType$(type: string) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$\n        .let(this.getStoreData$())\n        .map(resources => (resources ? resources[type] : undefined));\n    };\n  }\n/**\n * @param {?} query\n * @return {?}\n */\npublic queryStore$(query: Query) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      let /** @type {?} */ selected$: Observable<any>;\n      if (!query.type) {\n        return state$.map(() => Observable.throw('Unknown query'));\n      } else if (query.type && query.id) {\n        selected$ = state$.let(\n          this.getStoreResource$({ type: query.type, id: query.id })\n        );\n      } else {\n        selected$ = state$\n          .let(this.getStoreResourceOfType$(query.type))\n          .combineLatest(\n            state$.let(this.getStoreData$()),\n            (\n              resources: NgrxJsonApiStoreResources,\n              storeData: NgrxJsonApiStoreData\n            ) =>\n              filterResources(\n                resources,\n                storeData,\n                query,\n                this.config.resourceDefinitions,\n                this.config.filteringConfig\n              )\n          );\n      }\n      return selected$.distinctUntilChanged();\n    };\n  }\n/**\n * @return {?}\n */\npublic getStoreQueries$() {\n    return (state$: Store<NgrxJsonApiStore>) => {\n      return state$.select('queries');\n    };\n  }\n/**\n * @param {?} queryId\n * @return {?}\n */\npublic getResourceQuery$(queryId: string) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$\n        .let(this.getStoreQueries$())\n        .map(it => (it ? it[queryId] : undefined))\n    };\n  }\n/**\n * @param {?} identifier\n * @return {?}\n */\npublic getStoreResource$(identifier: ResourceIdentifier) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$\n        .let(this.getStoreResourceOfType$(identifier.type))\n        .map(\n          resources => /** @type {?} */((\n            (resources ? resources[identifier.id] : undefined) as StoreResource))\n        );\n    };\n  }\n/**\n * @param {?} queryId\n * @param {?} denormalize\n * @return {?}\n */\npublic getManyResults$(queryId: string, denormalize: boolean) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$.map(state => {\n        let /** @type {?} */ storeQuery = state.queries[queryId];\n        if (!storeQuery) {\n          return undefined;\n        }\n\n        if (_.isEmpty(storeQuery.resultIds)) {\n          let /** @type {?} */ queryResult: ManyQueryResult = {\n            ...storeQuery,\n            data: _.isUndefined(storeQuery.resultIds) ? undefined : [],\n          };\n          return queryResult;\n        } else {\n          let /** @type {?} */ results = storeQuery.resultIds.map(\n            id => (state.data[id.type] ? state.data[id.type][id.id] : undefined)\n          );\n          if (denormalize) {\n            results = denormaliseStoreResources(results, state.data);\n          }\n          return {\n            ...storeQuery,\n            data: /** @type {?} */(( results as Array<StoreResource>)),\n          };\n        }\n      });\n    };\n  }\n/**\n * @param {?} queryId\n * @param {?} denormalize\n * @return {?}\n */\npublic getOneResult$(queryId: string, denormalize: boolean) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$.map(state => {\n        let /** @type {?} */ storeQuery = state.queries[queryId];\n        if (!storeQuery) {\n          return undefined;\n        }\n\n        if (_.isEmpty(storeQuery.resultIds)) {\n          let /** @type {?} */ queryResult: ManyQueryResult = {\n            ...storeQuery,\n            data: _.isUndefined(storeQuery.resultIds) ? undefined : null,\n          };\n          return queryResult;\n        } else {\n          if (storeQuery.resultIds.length >= 2) {\n            throw new Error(\n              'expected single result for query ' + storeQuery.query.queryId\n            );\n          }\n\n          let /** @type {?} */ resultId = storeQuery.resultIds[0];\n          let /** @type {?} */ result = state.data[resultId.type]\n            ? state.data[resultId.type][resultId.id]\n            : undefined;\n          if (denormalize) {\n            result = denormaliseStoreResource(result, state.data);\n          }\n          return {\n            ...storeQuery,\n            data: result,\n          };\n        }\n      });\n    };\n  }\n/**\n * @param {?} identifier\n * @return {?}\n */\npublic getPersistedResource$(identifier: ResourceIdentifier) {\n    return (state$: Observable<NgrxJsonApiStore>) => {\n      return state$\n        .let(this.getStoreResource$(identifier))\n        .map(it => (it ? it.persistedResource : undefined));\n    };\n  }\n}\n\nfunction NgrxJsonApiSelectors_tsickle_Closure_declarations() {\n/** @type {?} */\nNgrxJsonApiSelectors.prototype.config;\n}\n\n","import { Action, ActionReducerMap } from '@ngrx/store';\n\nimport {\n  ApiApplyInitAction,\n  ApiRollbackAction,\n  NgrxJsonApiActionTypes,\n} from './actions';\nimport {\n  ModifyStoreResourceErrorsPayload,\n  NgrxJsonApiStore,\n  Query,\n  ResourceIdentifier,\n  StoreResource,\n} from './interfaces';\nimport {\n  clearQueryResult,\n  compactStore,\n  deleteStoreResources,\n  getPendingChanges,\n  removeQuery,\n  removeStoreResource,\n  rollbackStoreResources,\n  updateQueriesForDeletedResource,\n  updateQueryErrors,\n  updateQueryParams,\n  updateQueryResults,\n  updateResourceErrors,\n  updateResourceErrorsForQuery,\n  updateResourceState,\n  updateStoreDataFromPayload,\n  updateStoreDataFromResource,\n} from './utils';\n\nexport const /** @type {?} */ initialNgrxJsonApiState: NgrxJsonApiStore = {\n  isCreating: 0,\n  isReading: 0,\n  isUpdating: 0,\n  isDeleting: 0,\n  isApplying: 0,\n  data: {},\n  queries: {},\n};\n/**\n * @param {?=} state\n * @param {?=} action\n * @return {?}\n */\nexport function NgrxJsonApiStoreReducer(\n  state: NgrxJsonApiStore = initialNgrxJsonApiState,\n  action: any\n): NgrxJsonApiStore {\n  let /** @type {?} */ newState;\n\n  switch (action.type) {\n    case NgrxJsonApiActionTypes.API_POST_INIT: {\n      let /** @type {?} */ updatedData = updateStoreDataFromResource(\n        state.data,\n        action.payload,\n        false,\n        true\n      );\n      newState = {\n        ...state,\n        data: updatedData,\n        isCreating: state.isCreating + 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_GET_INIT: {\n      let /** @type {?} */ query = /** @type {?} */(( action.payload as Query));\n      newState = {\n        ...state,\n        queries: updateQueryParams(state.queries, query),\n        isReading: state.isReading + 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_PATCH_INIT: {\n      let /** @type {?} */ updatedData = updateStoreDataFromResource(\n        state.data,\n        action.payload,\n        false,\n        false\n      );\n      newState = {\n        ...state,\n        data: updatedData,\n        isUpdating: state.isUpdating + 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_DELETE_INIT: {\n      newState = {\n        ...state,\n        data: updateResourceState(state.data, action.payload, 'DELETED'),\n        isDeleting: state.isDeleting + 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_POST_SUCCESS: {\n      newState = {\n        ...state,\n        data: updateStoreDataFromPayload(\n          state.data,\n          action.payload.jsonApiData\n        ),\n        isCreating: state.isCreating - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_GET_SUCCESS: {\n      newState = {\n        ...state,\n        data: updateStoreDataFromPayload(\n          state.data,\n          action.payload.jsonApiData\n        ),\n        queries: updateQueryResults(\n          state.queries,\n          action.payload.query.queryId,\n          action.payload.jsonApiData\n        ),\n        isReading: state.isReading - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_PATCH_SUCCESS: {\n      newState = {\n        ...state,\n        data: updateStoreDataFromPayload(\n          state.data,\n          action.payload.jsonApiData\n        ),\n        isUpdating: state.isUpdating - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_DELETE_SUCCESS: {\n      newState = {\n        ...state,\n        data: deleteStoreResources(state.data, action.payload.query),\n        queries: updateQueriesForDeletedResource(state.queries, {\n          id: action.payload.query.id,\n          type: action.payload.query.type,\n        }),\n        isDeleting: state.isDeleting - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_QUERY_REFRESH: {\n      // clear result ids and wait until new data is fetched (triggered by effect)\n      newState = {\n        ...state,\n        queries: clearQueryResult(state.queries, action.payload),\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_POST_FAIL: {\n      newState = {\n        ...state,\n        data: updateResourceErrorsForQuery(\n          state.data,\n          action.payload.query,\n          action.payload.jsonApiData\n        ),\n        isCreating: state.isCreating - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_GET_FAIL: {\n      newState = {\n        ...state,\n        queries: updateQueryErrors(\n          state.queries,\n          action.payload.query.queryId,\n          action.payload.jsonApiData\n        ),\n        isReading: state.isReading - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_PATCH_FAIL: {\n      newState = {\n        ...state,\n        data: updateResourceErrorsForQuery(\n          state.data,\n          action.payload.query,\n          action.payload.jsonApiData\n        ),\n        isUpdating: state.isUpdating - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_DELETE_FAIL: {\n      newState = {\n        ...state,\n        data: updateResourceErrorsForQuery(\n          state.data,\n          action.payload.query,\n          action.payload.jsonApiData\n        ),\n        isDeleting: state.isDeleting - 1,\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.REMOVE_QUERY: {\n      let /** @type {?} */ queryId = /** @type {?} */(( action.payload as string));\n      newState = { ...state, queries: removeQuery(state.queries, queryId) };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.LOCAL_QUERY_INIT: {\n      let /** @type {?} */ query = /** @type {?} */(( action.payload as Query));\n      newState = { ...state, queries: updateQueryParams(state.queries, query) };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.MODIFY_STORE_RESOURCE_ERRORS: {\n      let /** @type {?} */ payload = /** @type {?} */(( action.payload as ModifyStoreResourceErrorsPayload));\n      newState = {\n        ...state,\n        data: updateResourceErrors(\n          state.data,\n          payload.resourceId,\n          payload.errors,\n          payload.modificationType\n        ),\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.LOCAL_QUERY_SUCCESS: {\n      newState = {\n        ...state,\n        queries: updateQueryResults(\n          state.queries,\n          action.payload.query.queryId,\n          action.payload.jsonApiData\n        ),\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.PATCH_STORE_RESOURCE: {\n      let /** @type {?} */ updatedData = updateStoreDataFromResource(\n        state.data,\n        action.payload,\n        false,\n        false\n      );\n      if (updatedData !== state.data) {\n        newState = { ...state, data: updatedData };\n        return newState;\n      } else {\n        return state;\n      }\n    }\n    case NgrxJsonApiActionTypes.POST_STORE_RESOURCE: {\n      let /** @type {?} */ updatedData = updateStoreDataFromResource(\n        state.data,\n        action.payload,\n        false,\n        true\n      );\n      if (updatedData !== state.data) {\n        newState = { ...state, data: updatedData };\n        return newState;\n      } else {\n        return state;\n      }\n    }\n    case NgrxJsonApiActionTypes.NEW_STORE_RESOURCE: {\n      let /** @type {?} */ updatedData = updateStoreDataFromResource(\n        state.data,\n        action.payload,\n        false,\n        true\n      );\n      updatedData = updateResourceState(updatedData, action.payload, 'NEW');\n      if (updatedData !== state.data) {\n        newState = { ...state, data: updatedData };\n        return newState;\n      } else {\n        return state;\n      }\n    }\n    case NgrxJsonApiActionTypes.DELETE_STORE_RESOURCE: {\n      let /** @type {?} */ resourceId = /** @type {?} */(( action.payload as ResourceIdentifier));\n      if (\n        state.data[resourceId.type] &&\n        state.data[resourceId.type][resourceId.id]\n      ) {\n        let /** @type {?} */ resource = state.data[resourceId.type][resourceId.id];\n\n        if (resource.state === 'NEW' || resource.state === 'CREATED') {\n          // not yet stored on server-side, just delete\n          newState = {\n            ...state,\n            data: removeStoreResource(state.data, resourceId),\n          };\n          return newState;\n        } else {\n          // stored on server, mark for deletion\n          newState = {\n            ...state,\n            data: updateResourceState(state.data, action.payload, 'DELETED'),\n          };\n          return newState;\n        }\n      }\n      return state;\n    }\n    case NgrxJsonApiActionTypes.API_APPLY_INIT: {\n      let /** @type {?} */ payload = ( /** @type {?} */((action as ApiApplyInitAction))).payload;\n      let /** @type {?} */ pending: Array<StoreResource> = getPendingChanges(\n        state.data,\n        payload.ids,\n        payload.include\n      );\n      newState = { ...state, isApplying: state.isApplying + 1 };\n      for (let /** @type {?} */ pendingChange of pending) {\n        if (pendingChange.state === 'CREATED') {\n          newState.isCreating++;\n        } else if (pendingChange.state === 'UPDATED') {\n          newState.isUpdating++;\n        } else if (pendingChange.state === 'DELETED') {\n          newState.isDeleting++;\n        } else {\n          throw new Error('unknown state ' + pendingChange.state);\n        }\n      }\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_APPLY_SUCCESS:\n    case NgrxJsonApiActionTypes.API_APPLY_FAIL: {\n      // apply all the committed or failed changes\n      let /** @type {?} */ actions = /** @type {?} */(( action.payload as Array<Action>));\n      newState = state;\n      for (let /** @type {?} */ commitAction of actions) {\n        newState = NgrxJsonApiStoreReducer(newState, commitAction);\n      }\n      newState = { ...newState, isApplying: state['isApplying'] - 1 };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.API_ROLLBACK: {\n      let /** @type {?} */ payload = ( /** @type {?} */((action as ApiRollbackAction))).payload;\n      newState = {\n        ...state,\n        data: rollbackStoreResources(state.data, payload.ids, payload.include),\n      };\n      return newState;\n    }\n    case NgrxJsonApiActionTypes.CLEAR_STORE: {\n      return initialNgrxJsonApiState;\n    }\n    case NgrxJsonApiActionTypes.COMPACT_STORE: {\n      return compactStore(state);\n    }\n    default:\n      return state;\n  }\n}\n\nexport const /** @type {?} */ reducer: ActionReducerMap<any> = {\n  api: NgrxJsonApiStoreReducer,\n};\n","import { ModuleWithProviders, NgModule, OpaqueToken } from '@angular/core';\n\nimport { HttpClient } from '@angular/common/http';\n\nimport { Store, StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\n\nimport { NgrxJsonApi } from './api';\nimport { NgrxJsonApiEffects } from './effects';\nimport { NgrxJsonApiSelectors } from './selectors';\nimport { NgrxJsonApiService } from './services';\nimport { reducer } from './reducers';\nimport {\n  DenormaliseStoreResourcePipe,\n  GetDenormalisedValuePipe,\n  SelectStoreResourcePipe,\n} from './pipes';\n\nimport { NgrxJsonApiConfig } from './interfaces';\n\nexport const /** @type {?} */ NGRX_JSON_API_CONFIG = new OpaqueToken('NGRX_JSON_API_CONFIG');\n/**\n * @param {?} http\n * @param {?} config\n * @return {?}\n */\nexport function apiFactory(http: HttpClient, config: NgrxJsonApiConfig) {\n  return new NgrxJsonApi(http, config);\n}\n/**\n * @param {?} config\n * @return {?}\n */\nexport function selectorsFactory(config: NgrxJsonApiConfig) {\n  return new NgrxJsonApiSelectors(config);\n}\n/**\n * @param {?} store\n * @param {?} selectors\n * @return {?}\n */\nexport function serviceFactory(\n  store: Store<any>,\n  selectors: NgrxJsonApiSelectors\n) {\n  return new NgrxJsonApiService(store, selectors);\n}\n/**\n * @param {?} config\n * @return {?}\n */\nexport function configure(config: NgrxJsonApiConfig): Array<any> {\n  return [\n    {\n      provide: NgrxJsonApi,\n      useFactory: apiFactory,\n      deps: [HttpClient, NGRX_JSON_API_CONFIG],\n    },\n    {\n      provide: NgrxJsonApiSelectors,\n      useFactory: selectorsFactory,\n      deps: [NGRX_JSON_API_CONFIG],\n    },\n    {\n      provide: NgrxJsonApiService,\n      useFactory: serviceFactory,\n      deps: [Store, NgrxJsonApiSelectors],\n    },\n    {\n      provide: NGRX_JSON_API_CONFIG,\n      useValue: config,\n    },\n  ];\n}\nexport class NgrxJsonApiModule {\n/**\n * @param {?} config\n * @return {?}\n */\nstatic configure(config: NgrxJsonApiConfig): ModuleWithProviders {\n    return {\n      ngModule: NgrxJsonApiModule,\n      providers: configure(config),\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    DenormaliseStoreResourcePipe,\n    GetDenormalisedValuePipe,\n    SelectStoreResourcePipe,\n  ],\n  imports: [\n    EffectsModule.forFeature([NgrxJsonApiEffects]),\n    StoreModule.forFeature('NgrxJsonApi', reducer, {}),\n  ],\n  exports: [\n    DenormaliseStoreResourcePipe,\n    GetDenormalisedValuePipe,\n    SelectStoreResourcePipe,\n  ],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction NgrxJsonApiModule_tsickle_Closure_declarations() {\n/** @type {?} */\nNgrxJsonApiModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgrxJsonApiModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Observable } from 'rxjs/Observable';\nimport { AnonymousSubscription } from 'rxjs/Subscription';\nexport type Direction = number;\nexport let Direction: any = {};\nDirection.ASC = 0;\nDirection.DESC = 1;\nDirection[Direction.ASC] = \"ASC\";\nDirection[Direction.DESC] = \"DESC\";\n\n\nexport interface Document {\n  data?: any;\n  included?: any;\n  meta?: any;\n  links?: any;\n  errors?: Array<ResourceError>;\n}\n\nexport interface FilteringParam {\n  path?: string;\n  operator?: string;\n  value?: any;\n}\n\nexport interface FilteringOperator {\n  name: string;\n  apiName?: string;\n  comparison: (value: any, resourceFieldValue: any) => boolean;\n}\n\nexport interface ManyResourceRelationship {\n  data?: Array<ResourceIdentifier>;\n  reference?: Array<StoreResource>;\n}\n\n/**\n * Used by code generators to navigate relationships in a type-safe manner.\n * See crnk.io for a first such generator.\n */\nexport interface TypedManyResourceRelationship<T extends StoreResource>\n  extends ManyResourceRelationship {\n  reference?: Array<T>;\n}\n\n/**\n * Used by code generators to navigate relationships in a type-safe manner.\n * See crnk.io for a first such generator.\n */\nexport interface TypedOneResourceRelationship<T extends StoreResource>\n  extends OneResourceRelationship {\n  reference?: T;\n}\n\nexport interface NgrxJsonApiConfig {\n  apiUrl: string;\n  initialState?: any;\n  resourceDefinitions?: Array<ResourceDefinition>;\n  urlBuilder?: NgrxJsonApiUrlBuilder;\n  filteringConfig?: NgrxJsonApiFilteringConfig;\n\n  /**\n   * Allows to disable the apply action and replace it with a custom one. For example\n   * have a look at www.crnk.io that makes use of JSON PATCH to perform bulk updates.\n   */\n  applyEnabled?: boolean;\n}\n\nexport interface NgrxJsonApiStore {\n  data: NgrxJsonApiStoreData;\n  queries: NgrxJsonApiStoreQueries;\n  isCreating: number;\n  isReading: number;\n  isUpdating: number;\n  isDeleting: number;\n  isApplying: number;\n}\n\nexport interface NgrxJsonApiStoreData {\n  [id: string]: NgrxJsonApiStoreResources;\n}\n\nexport interface NgrxJsonApiStoreQueries {\n  [id: string]: StoreQuery;\n}\n\nexport interface NgrxJsonApiStoreResources {\n  [id: string]: StoreResource;\n}\n\nexport interface NgrxJsonApiFilteringConfig {\n  pathSeparator?: string;\n  filteringOperators?: Array<FilteringOperator>;\n}\n\nexport interface NgrxJsonApiUrlBuilder {\n  generateFilteringQueryParams?: (params: Array<FilteringParam>) => string;\n  generateFieldsQueryParams?: (params: Array<string>) => string;\n  generateIncludedQueryParams?: (params: Array<string>) => string;\n  generateSortingQueryParams?: (params: Array<SortingParam>) => string;\n  generateQueryParams?: (...params: Array<string>) => string;\n}\n\nexport type OperationType = 'GET' | 'DELETE' | 'PATCH' | 'POST' | false;\n\nexport interface OneResourceRelationship {\n  data?: ResourceIdentifier;\n  reference?: StoreResource;\n}\n\nexport type ErrorModificationType = 'ADD' | 'REMOVE' | 'SET';\n\nexport interface ModifyStoreResourceErrorsPayload {\n  resourceId: ResourceIdentifier;\n  errors: Array<ResourceError>;\n  modificationType: ErrorModificationType;\n}\n\nexport interface Payload {\n  jsonApiData?: Document;\n  query?: Query;\n}\n\nexport interface Query {\n  queryId?: string;\n  type?: string;\n  id?: string;\n  params?: QueryParams;\n}\n\nexport interface QueryParams {\n  filtering?: Array<FilteringParam>;\n  sorting?: Array<SortingParam>;\n  include?: Array<string>;\n  fields?: Array<string>;\n  offset?: number;\n  limit?: number;\n}\n\nexport interface Resource extends ResourceIdentifier {\n  attributes?: { [key: string]: any };\n  relationships?: { [key: string]: ResourceRelationship };\n  meta?: any;\n  links?: any;\n}\n\nexport interface ResourceAttributeDefinition {\n  apiName?: string;\n}\n\nexport interface ResourceDefinition {\n  type: string;\n  collectionPath: string;\n  attributes?: { [key: string]: ResourceAttributeDefinition };\n  relationships?: { [key: string]: ResourceRelationDefinition };\n}\n\nexport interface ResourceError {\n  id?: string;\n  links?: any;\n  status?: string;\n  code?: string;\n  title?: string;\n  detail?: string;\n  source?: ResourceErrorSource;\n  meta?: any;\n}\n\nexport interface ResourceErrorSource {\n  pointer?: string;\n  parameter?: string;\n}\n\nexport interface ResourceIdentifier {\n  type: string;\n  id: string;\n}\n\nexport interface ResourceRelationship {\n  data?: any;\n  links?: any;\n  reference?: any;\n}\n\nexport interface ResourceRelationDefinition {\n  type: string;\n  relationType: ResourceRelationType;\n}\n\nexport type ResourceRelationType = 'hasOne' | 'hasMany';\n\nexport type ResourceState =\n  | 'NEW'\n  | 'IN_SYNC'\n  | 'CREATED'\n  | 'UPDATED'\n  | 'DELETED'\n  | 'NOT_LOADED';\n\nexport interface SortingParam {\n  api: string;\n  direction: Direction;\n}\n\nexport interface QueryResult extends StoreQuery {\n  data?: StoreResource | Array<StoreResource>;\n}\n\nexport interface ManyQueryResult extends QueryResult {\n  data?: Array<StoreResource>;\n}\n\nexport interface OneQueryResult extends QueryResult {\n  data?: StoreResource;\n}\n\nexport interface StoreQuery {\n  query: Query;\n  loading: Boolean;\n  resultIds?: Array<ResourceIdentifier>;\n  meta?: any;\n  links?: any;\n\n  /**\n   * Errors received from the server after attempting to perform a GET request.\n   */\n  errors: Array<ResourceError>;\n}\n\n/**\n* Container to hold a Resource in the store with state information.\n*/\nexport interface StoreResource extends Resource {\n  /**\n  * State of the resource to track local changes not yet\n  * published to the json api endpoint.\n  */\n  state?: ResourceState;\n  /**\n  * The original resource obtained from the server.\n  */\n  persistedResource?: Resource;\n  /**\n  * One of the operation types: reading, creating, updating or deleting.\n  */\n  loading?: OperationType;\n  /**\n  * Errors received from the server after attempting to store the resource.\n  */\n  errors?: Array<ResourceError>;\n\n  /**\n   * new resources may only obtain an id when posted to the server. Till that point\n   * a StoreResource can assign make use of a temporary id and signal this by setting\n   * this flag to true. The id will not be transmitted to the server and the resource\n   * is removed from its temporary location (given by its id) as soon as it is posted\n   * to the server.\n   */\n  hasTemporaryId?: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { Action } from '@ngrx/store';\n\nimport {\n  Payload,\n  Resource,\n  ResourceIdentifier,\n  Query,\n  ModifyStoreResourceErrorsPayload,\n} from './interfaces';\n\nexport const /** @type {?} */ NgrxJsonApiActionTypes = {\n  API_POST_INIT: '[NgrxJsonApi] API_POST_INIT',\n  API_POST_SUCCESS: '[NgrxJsonApi] API_POST_SUCCESS',\n  API_POST_FAIL: '[NgrxJsonApi] API_POST_FAIL',\n  API_GET_INIT: '[NgrxJsonApi] API_GET_INIT',\n  API_GET_SUCCESS: '[NgrxJsonApi] API_GET_SUCCESS',\n  API_GET_FAIL: '[NgrxJsonApi] API_GET_FAIL',\n  API_PATCH_INIT: '[NgrxJsonApi] API_PATCH_INIT',\n  API_PATCH_SUCCESS: '[NgrxJsonApi] API_PATCH_SUCCESS',\n  API_PATCH_FAIL: '[NgrxJsonApi] API_PATCH_FAIL',\n  API_DELETE_INIT: '[NgrxJsonApi] API_DELETE_INIT',\n  API_DELETE_SUCCESS: '[NgrxJsonApi] API_DELETE_SUCCESS',\n  API_DELETE_FAIL: '[NgrxJsonApi] API_DELETE_FAIL',\n  API_APPLY_INIT: '[NgrxJsonApi] API_APPLY_INIT',\n  API_APPLY_SUCCESS: '[NgrxJsonApi] API_APPLY_SUCCESS',\n  API_APPLY_FAIL: '[NgrxJsonApi] API_APPLY_FAIL',\n  API_ROLLBACK: '[NgrxJsonApi] API_ROLLBACK',\n  API_QUERY_REFRESH: '[NgrxJsonApi] API_QUERY_REFRESH',\n  LOCAL_QUERY_INIT: '[NgrxJsonApi] LOCAL_QUERY_INIT',\n  LOCAL_QUERY_SUCCESS: '[NgrxJsonApi] LOCAL_QUERY_SUCCESS',\n  LOCAL_QUERY_FAIL: '[NgrxJsonApi] LOCAL_QUERY_FAIL',\n  DELETE_STORE_RESOURCE: '[NgrxJsonApi] DELETE_STORE_RESOURCE',\n  PATCH_STORE_RESOURCE: '[NgrxJsonApi] PATCH_STORE_RESOURCE',\n  NEW_STORE_RESOURCE: '[NgrxJsonApi] NEW_STORE_RESOURCE',\n  POST_STORE_RESOURCE: '[NgrxJsonApi] POST_STORE_RESOURCE',\n  MODIFY_STORE_RESOURCE_ERRORS: '[NgrxJsonApi] MODIFY_STORE_RESOURCE_ERRORS',\n  REMOVE_QUERY: '[NgrxJsonApi] REMOVE_QUERY',\n  COMPACT_STORE: '[NgrxJsonApi] COMPACT_STORE',\n  CLEAR_STORE: '[NgrxJsonApi] CLEAR_STORE',\n};\n\nexport interface ApiApplyInitPayload {\n  /**\n   * optional list of resource identifiers to perform apply. If not specified all change will be applied\n   * to the backend.\n   */\n  ids?: Array<ResourceIdentifier>;\n\n  /**\n   * if the apply action is restricted to a set of resources with the ids parameter. The include flag allows to\n   * specify which relationships to apply as well. Nested relationships are separated by a dot.\n   */\n  include?: Array<string>;\n}\n\nexport interface ApiApplyRollbackPayload extends ApiApplyInitPayload {}\nexport class ApiApplyInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_APPLY_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: ApiApplyInitPayload) {}\n}\n\nfunction ApiApplyInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiApplyInitAction.prototype.type;\n/** @type {?} */\nApiApplyInitAction.prototype.payload;\n}\n\nexport class ApiApplySuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_APPLY_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Array<Action>) {}\n}\n\nfunction ApiApplySuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiApplySuccessAction.prototype.type;\n/** @type {?} */\nApiApplySuccessAction.prototype.payload;\n}\n\nexport class ApiApplyFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_APPLY_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Array<Action>) {}\n}\n\nfunction ApiApplyFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiApplyFailAction.prototype.type;\n/** @type {?} */\nApiApplyFailAction.prototype.payload;\n}\n\nexport class ApiPostInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_POST_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Resource) {}\n}\n\nfunction ApiPostInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPostInitAction.prototype.type;\n/** @type {?} */\nApiPostInitAction.prototype.payload;\n}\n\nexport class ApiPostSuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_POST_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiPostSuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPostSuccessAction.prototype.type;\n/** @type {?} */\nApiPostSuccessAction.prototype.payload;\n}\n\nexport class ApiPostFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_POST_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiPostFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPostFailAction.prototype.type;\n/** @type {?} */\nApiPostFailAction.prototype.payload;\n}\n\nexport class ApiDeleteInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_DELETE_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: ResourceIdentifier) {}\n}\n\nfunction ApiDeleteInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiDeleteInitAction.prototype.type;\n/** @type {?} */\nApiDeleteInitAction.prototype.payload;\n}\n\nexport class ApiDeleteSuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_DELETE_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiDeleteSuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiDeleteSuccessAction.prototype.type;\n/** @type {?} */\nApiDeleteSuccessAction.prototype.payload;\n}\n\nexport class ApiDeleteFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_DELETE_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiDeleteFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiDeleteFailAction.prototype.type;\n/** @type {?} */\nApiDeleteFailAction.prototype.payload;\n}\n\nexport class ApiGetInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_GET_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Query) {}\n}\n\nfunction ApiGetInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiGetInitAction.prototype.type;\n/** @type {?} */\nApiGetInitAction.prototype.payload;\n}\n\nexport class ApiGetSuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_GET_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiGetSuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiGetSuccessAction.prototype.type;\n/** @type {?} */\nApiGetSuccessAction.prototype.payload;\n}\n\nexport class ApiGetFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_GET_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiGetFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiGetFailAction.prototype.type;\n/** @type {?} */\nApiGetFailAction.prototype.payload;\n}\n\nexport class ApiRollbackAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_ROLLBACK;\n/**\n * @param {?} payload\n */\nconstructor(public payload: ApiApplyRollbackPayload) {}\n}\n\nfunction ApiRollbackAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiRollbackAction.prototype.type;\n/** @type {?} */\nApiRollbackAction.prototype.payload;\n}\n\nexport class ApiPatchInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_PATCH_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Resource) {}\n}\n\nfunction ApiPatchInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPatchInitAction.prototype.type;\n/** @type {?} */\nApiPatchInitAction.prototype.payload;\n}\n\nexport class ApiPatchSuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_PATCH_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiPatchSuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPatchSuccessAction.prototype.type;\n/** @type {?} */\nApiPatchSuccessAction.prototype.payload;\n}\n\nexport class ApiPatchFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_PATCH_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction ApiPatchFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiPatchFailAction.prototype.type;\n/** @type {?} */\nApiPatchFailAction.prototype.payload;\n}\n\nexport class DeleteStoreResourceAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.DELETE_STORE_RESOURCE;\n/**\n * @param {?} payload\n */\nconstructor(public payload: ResourceIdentifier) {}\n}\n\nfunction DeleteStoreResourceAction_tsickle_Closure_declarations() {\n/** @type {?} */\nDeleteStoreResourceAction.prototype.type;\n/** @type {?} */\nDeleteStoreResourceAction.prototype.payload;\n}\n\nexport class PatchStoreResourceAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.PATCH_STORE_RESOURCE;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Resource) {}\n}\n\nfunction PatchStoreResourceAction_tsickle_Closure_declarations() {\n/** @type {?} */\nPatchStoreResourceAction.prototype.type;\n/** @type {?} */\nPatchStoreResourceAction.prototype.payload;\n}\n\nexport class NewStoreResourceAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.NEW_STORE_RESOURCE;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Resource) {}\n}\n\nfunction NewStoreResourceAction_tsickle_Closure_declarations() {\n/** @type {?} */\nNewStoreResourceAction.prototype.type;\n/** @type {?} */\nNewStoreResourceAction.prototype.payload;\n}\n\nexport class PostStoreResourceAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.POST_STORE_RESOURCE;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Resource) {}\n}\n\nfunction PostStoreResourceAction_tsickle_Closure_declarations() {\n/** @type {?} */\nPostStoreResourceAction.prototype.type;\n/** @type {?} */\nPostStoreResourceAction.prototype.payload;\n}\n\nexport class RemoveQueryAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.REMOVE_QUERY;\n/**\n * @param {?} payload\n */\nconstructor(public payload: string) {}\n}\n\nfunction RemoveQueryAction_tsickle_Closure_declarations() {\n/** @type {?} */\nRemoveQueryAction.prototype.type;\n/** @type {?} */\nRemoveQueryAction.prototype.payload;\n}\n\nexport class LocalQueryInitAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.LOCAL_QUERY_INIT;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Query) {}\n}\n\nfunction LocalQueryInitAction_tsickle_Closure_declarations() {\n/** @type {?} */\nLocalQueryInitAction.prototype.type;\n/** @type {?} */\nLocalQueryInitAction.prototype.payload;\n}\n\nexport class LocalQuerySuccessAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.LOCAL_QUERY_SUCCESS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction LocalQuerySuccessAction_tsickle_Closure_declarations() {\n/** @type {?} */\nLocalQuerySuccessAction.prototype.type;\n/** @type {?} */\nLocalQuerySuccessAction.prototype.payload;\n}\n\nexport class LocalQueryFailAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.LOCAL_QUERY_FAIL;\n/**\n * @param {?} payload\n */\nconstructor(public payload: Payload) {}\n}\n\nfunction LocalQueryFailAction_tsickle_Closure_declarations() {\n/** @type {?} */\nLocalQueryFailAction.prototype.type;\n/** @type {?} */\nLocalQueryFailAction.prototype.payload;\n}\n\nexport class CompactStoreAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.COMPACT_STORE;\nconstructor() {}\n}\n\nfunction CompactStoreAction_tsickle_Closure_declarations() {\n/** @type {?} */\nCompactStoreAction.prototype.type;\n}\n\nexport class ClearStoreAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.CLEAR_STORE;\nconstructor() {}\n}\n\nfunction ClearStoreAction_tsickle_Closure_declarations() {\n/** @type {?} */\nClearStoreAction.prototype.type;\n}\n\nexport class ApiQueryRefreshAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.API_QUERY_REFRESH;\n/**\n * @param {?} payload\n */\nconstructor(public payload: string) {\n    if (!payload) {\n      throw new Error('no query id provided for ApiQueryRefreshAction');\n    }\n  }\n}\n\nfunction ApiQueryRefreshAction_tsickle_Closure_declarations() {\n/** @type {?} */\nApiQueryRefreshAction.prototype.type;\n/** @type {?} */\nApiQueryRefreshAction.prototype.payload;\n}\n\nexport class ModifyStoreResourceErrorsAction implements Action {\n  readonly type = NgrxJsonApiActionTypes.MODIFY_STORE_RESOURCE_ERRORS;\n/**\n * @param {?} payload\n */\nconstructor(public payload: ModifyStoreResourceErrorsPayload) {}\n}\n\nfunction ModifyStoreResourceErrorsAction_tsickle_Closure_declarations() {\n/** @type {?} */\nModifyStoreResourceErrorsAction.prototype.type;\n/** @type {?} */\nModifyStoreResourceErrorsAction.prototype.payload;\n}\n\n\nexport type NgrxJsonApiActions =\n  | ApiApplyInitAction\n  | ApiApplySuccessAction\n  | ApiApplyFailAction\n  | ApiPostInitAction\n  | ApiPostSuccessAction\n  | ApiPostFailAction\n  | ApiDeleteInitAction\n  | ApiDeleteSuccessAction\n  | ApiDeleteFailAction\n  | ApiGetInitAction\n  | ApiGetSuccessAction\n  | ApiGetFailAction\n  | ApiRollbackAction\n  | ApiPatchInitAction\n  | ApiPatchSuccessAction\n  | ApiPatchFailAction\n  | DeleteStoreResourceAction\n  | PatchStoreResourceAction\n  | PostStoreResourceAction\n  | NewStoreResourceAction\n  | RemoveQueryAction\n  | ApiQueryRefreshAction\n  | LocalQueryInitAction\n  | LocalQuerySuccessAction\n  | LocalQueryFailAction\n  | ModifyStoreResourceErrorsAction\n  | CompactStoreAction\n  | ClearStoreAction;\n","import * as _ from 'lodash/index';\n\nimport { Observable } from 'rxjs/Observable';\nimport'rxjs/add/operator/finally';\n\nimport { Store } from '@ngrx/store';\n\nimport { NgrxJsonApiSelectors } from './selectors';\nimport {\n  ApiApplyInitAction,\n  ApiPostInitAction,\n  ApiGetInitAction,\n  ApiPatchInitAction,\n  ApiDeleteInitAction,\n  DeleteStoreResourceAction,\n  PatchStoreResourceAction,\n  PostStoreResourceAction,\n  RemoveQueryAction,\n  LocalQueryInitAction,\n  ClearStoreAction,\n  CompactStoreAction,\n  ApiQueryRefreshAction,\n  ModifyStoreResourceErrorsAction,\n  NewStoreResourceAction,\n} from './actions';\nimport {\n  NgrxJsonApiStore,\n  NgrxJsonApiStoreData,\n  Resource,\n  ResourceIdentifier,\n  Query,\n  QueryResult,\n  OneQueryResult,\n  ManyQueryResult,\n  StoreResource,\n  ResourceError,\n} from './interfaces';\nimport {\n  denormaliseStoreResource,\n  denormaliseStoreResources,\n  getDenormalisedPath,\n  getDenormalisedValue,\n  uuid,\n} from './utils';\n\nexport interface FindOptions {\n  query: Query;\n  fromServer?: boolean;\n  denormalise?: boolean;\n}\n\nexport interface PutQueryOptions {\n  query: Query;\n  fromServer?: boolean;\n}\n\nexport interface PostResourceOptions {\n  resource: Resource;\n  toRemote?: boolean;\n}\n\nexport interface PatchResourceOptions {\n  resource: Resource;\n  toRemote?: boolean;\n}\n\nexport interface NewResourceOptions {\n  resource: Resource;\n}\n\nexport interface DeleteResourceOptions {\n  resourceId: ResourceIdentifier;\n  toRemote?: boolean;\n}\n\n/**\n * This internface is deprecated, do no longer use.\n */\nexport interface Options {\n  query?: Query;\n  denormalise?: boolean;\n  fromServer?: boolean;\n  resource?: Resource;\n  toRemote?: boolean;\n  resourceId?: ResourceIdentifier;\n}\nexport class NgrxJsonApiService {\nprivate test = true;\n/**\n * Keeps current snapshot of the store to allow fast access to resources.\n */\nprivate _storeSnapshot: NgrxJsonApiStore;\n/**\n * @param {?} store\n * @param {?} selectors\n */\nconstructor(\nprivate store: Store<any>,\nprivate selectors: NgrxJsonApiSelectors\n  ) {}\n/**\n * @param {?} options\n * @return {?}\n */\npublic findOne(options: FindOptions): Observable<OneQueryResult> {\n    return /** @type {?} */(( <Observable<OneQueryResult>>this.findInternal(options, false)));\n  }\n/**\n * @param {?} options\n * @return {?}\n */\npublic findMany(options: FindOptions): Observable<ManyQueryResult> {\n    return /** @type {?} */(( <Observable<ManyQueryResult>>this.findInternal(options, true)));\n  }\n/**\n * @return {?}\n */\npublic get storeSnapshot() {\n    if (!this._storeSnapshot) {\n      this.store\n        .let(this.selectors.getNgrxJsonApiStore$())\n        .subscribe(it => (this._storeSnapshot = /** @type {?} */(( it as NgrxJsonApiStore))));\n\n      if (!this._storeSnapshot) {\n        throw new Error('failed to initialize store snapshot');\n      }\n    }\n    return this._storeSnapshot;\n  }\n/**\n * Adds the given query to the store. Any existing query with the same queryId is replaced.\n * Make use of selectResults(...) to fetch the data.\n * @param {?} options\n * @return {?}\n */\npublic putQuery(options: PutQueryOptions) {\n    let /** @type {?} */ query = options.query;\n    let /** @type {?} */ fromServer = _.isUndefined(options.fromServer)\n      ? true\n      : options.fromServer;\n\n    if (!query.queryId) {\n      throw new Error('to query must have a queryId');\n    }\n\n    if (fromServer) {\n      this.store.dispatch(new ApiGetInitAction(query));\n    } else {\n      this.store.dispatch(new LocalQueryInitAction(query));\n    }\n  }\n/**\n * @param {?} queryId\n * @return {?}\n */\npublic refreshQuery(queryId: string) {\n    this.store.dispatch(new ApiQueryRefreshAction(queryId));\n  }\n/**\n * @param {?} queryId\n * @return {?}\n */\npublic removeQuery(queryId: string) {\n    this.store.dispatch(new RemoveQueryAction(queryId));\n  }\n/**\n * @param {?} options\n * @param {?} multi\n * @return {?}\n */\nprivate findInternal(\n    options: FindOptions,\n    multi: boolean\n  ): Observable<QueryResult> {\n    let /** @type {?} */ query = options.query;\n    let /** @type {?} */ fromServer = _.isUndefined(options.fromServer)\n      ? true\n      : options.fromServer;\n    let /** @type {?} */ denormalise = _.isUndefined(options.denormalise)\n      ? false\n      : options.denormalise;\n\n    let /** @type {?} */ newQuery: Query;\n    if (!query.queryId) {\n      newQuery = { ...query, queryId: this.uuid() };\n    } else {\n      newQuery = query;\n    }\n\n    this.putQuery({ query: newQuery, fromServer });\n\n    let /** @type {?} */ queryResult$: Observable<QueryResult>;\n    if (multi) {\n      queryResult$ = this.selectManyResults(newQuery.queryId, denormalise);\n    } else {\n      queryResult$ = this.selectOneResults(newQuery.queryId, denormalise);\n    }\n\n    return /** @type {?} */(( <Observable<QueryResult>>queryResult$.finally(() =>\n      this.removeQuery(newQuery.queryId)\n    )));\n  }\n/**\n * @return {?}\n */\nprivate uuid() {\n    return uuid();\n  }\n/**\n * Gets the current persisted state of the given resources.\n * Consider the use of selectResource(...) to get an observable of the resource.\n * \n * @param {?} identifier\n * @return {?}\n */\npublic getPersistedResourceSnapshot(identifier: ResourceIdentifier) {\n    let /** @type {?} */ snapshot = this.storeSnapshot;\n    if (\n      snapshot.data[identifier.type] &&\n      snapshot.data[identifier.type][identifier.id]\n    ) {\n      return snapshot.data[identifier.type][identifier.id].persistedResource;\n    }\n    return null;\n  }\n/**\n * Gets the current state of the given resources in the store.\n * Consider the use of selectResource(...) to get an observable of the resource.\n * \n * @param {?} identifier\n * @return {?}\n */\npublic getResourceSnapshot(identifier: ResourceIdentifier) {\n    let /** @type {?} */ snapshot = this.storeSnapshot;\n    if (\n      snapshot.data[identifier.type] &&\n      snapshot.data[identifier.type][identifier.id]\n    ) {\n      return snapshot.data[identifier.type][identifier.id];\n    }\n    return null;\n  }\n/**\n * Selects the data of the given query.\n * \n * @param {?} queryId\n * @param {?=} denormalize\n * @return {?} observable holding the data as array of resources.\n */\npublic selectManyResults(\n    queryId: string,\n    denormalize = false\n  ): Observable<ManyQueryResult> {\n    let /** @type {?} */ queryResult$ = this.store\n      .let(this.selectors.getNgrxJsonApiStore$())\n      .let(this.selectors.getManyResults$(queryId, denormalize));\n    return queryResult$;\n  }\n/**\n * Selects the data of the given query.\n * \n * @param {?} queryId\n * @param {?=} denormalize\n * @return {?} observable holding the data as array of resources.\n */\npublic selectOneResults(\n    queryId: string,\n    denormalize = false\n  ): Observable<OneQueryResult> {\n    let /** @type {?} */ queryResult$ = this.store\n      .let(this.selectors.getNgrxJsonApiStore$())\n      .let(this.selectors.getOneResult$(queryId, denormalize));\n    return /** @type {?} */(( queryResult$ as Observable<OneQueryResult>));\n  }\n/**\n * @param {?} identifier of the resource\n * @return {?} observable of the resource\n */\npublic selectStoreResource(\n    identifier: ResourceIdentifier\n  ): Observable<StoreResource> {\n    return this.store\n      .let(this.selectors.getNgrxJsonApiStore$())\n      .let(this.selectors.getStoreResource$(identifier));\n  }\n/**\n * @param {?} storeResource$\n * @return {?}\n */\npublic denormaliseResource(\n    storeResource$: Observable<StoreResource> | Observable<StoreResource[]>\n  ): Observable<StoreResource> | Observable<StoreResource[]> {\n    return /** @type {?} */(( <\n      | Observable<StoreResource>\n      | Observable<StoreResource[]>>storeResource$.combineLatest(\n      this.store\n        .let(this.selectors.getNgrxJsonApiStore$())\n        .let(this.selectors.getStoreData$()),\n      (\n        storeResource: StoreResource | StoreResource[],\n        storeData: NgrxJsonApiStoreData\n      ) => {\n        if (_.isArray(storeResource)) {\n          return denormaliseStoreResources( /** @type {?} */((\n            storeResource as Array<StoreResource>)),\n            storeData\n          );\n        } else {\n          let /** @type {?} */ resource = /** @type {?} */(( storeResource as StoreResource));\n          return /** @type {?} */(( denormaliseStoreResource(resource, storeData) as StoreResource));\n        }\n      }\n    )));\n  }\n/**\n * @param {?} path\n * @param {?} resourceType\n * @return {?}\n */\npublic getDenormalisedPath(path: string, resourceType: string): string {\n    let /** @type {?} */ pathSeparator = /** @type {?} */(( _.get(\n      this.selectors.config,\n      'filteringConfig.pathSeparator'\n    ) as string));\n    return getDenormalisedPath(\n      path,\n      resourceType,\n      this.selectors.config.resourceDefinitions,\n      pathSeparator\n    );\n  }\n/**\n * @param {?} path\n * @param {?} storeResource\n * @return {?}\n */\npublic getDenormalisedValue(path: string, storeResource: StoreResource): any {\n    let /** @type {?} */ pathSeparator = /** @type {?} */(( _.get(\n      this.selectors.config,\n      'filteringConfig.pathSeparator'\n    ) as string));\n    return getDenormalisedValue(\n      path,\n      storeResource,\n      this.selectors.config.resourceDefinitions,\n      pathSeparator\n    );\n  }\n/**\n * Updates the given resource in the store with the provided data.\n * Use commit() to send the changes to the remote JSON API endpoint.\n * \n * @param {?} options\n * @return {?}\n */\npublic patchResource(options: PatchResourceOptions) {\n    let /** @type {?} */ resource = options.resource;\n    let /** @type {?} */ toRemote = _.isUndefined(options.toRemote) ? false : options.toRemote;\n\n    if (toRemote) {\n      this.store.dispatch(new ApiPatchInitAction(resource));\n    } else {\n      this.store.dispatch(new PatchStoreResourceAction(resource));\n    }\n  }\n/**\n * Creates a new resources that is hold locally in the store\n * and my later be posted.\n * \n * @param {?} options\n * @return {?}\n */\npublic newResource(options: NewResourceOptions) {\n    let /** @type {?} */ resource = options.resource;\n    this.store.dispatch(new NewStoreResourceAction(resource));\n  }\n/**\n * Adds the given resource to the store. Any already existing\n * resource with the same id gets replaced. Use commit() to send\n * the changes to the remote JSON API endpoint.\n * \n * @param {?} options\n * @return {?}\n */\npublic postResource(options: PostResourceOptions) {\n    let /** @type {?} */ resource = options.resource;\n    let /** @type {?} */ toRemote = _.isUndefined(options.toRemote) ? false : options.toRemote;\n\n    if (toRemote) {\n      this.store.dispatch(new ApiPostInitAction(resource));\n    } else {\n      this.store.dispatch(new PostStoreResourceAction(resource));\n    }\n  }\n/**\n * Marks the given resource for deletion.\n * \n * @param {?} options\n * @return {?}\n */\npublic deleteResource(options: DeleteResourceOptions) {\n    let /** @type {?} */ resourceId = options.resourceId;\n    let /** @type {?} */ toRemote = _.isUndefined(options.toRemote) ? false : options.toRemote;\n\n    if (toRemote) {\n      this.store.dispatch(new ApiDeleteInitAction(resourceId));\n    } else {\n      this.store.dispatch(new DeleteStoreResourceAction(resourceId));\n    }\n  }\n/**\n * Applies all pending changes to the remote JSON API endpoint.\n * @return {?}\n */\npublic apply() {\n    this.store.dispatch(new ApiApplyInitAction({}));\n  }\n/**\n * Clear all the contents from the store.\n * @return {?}\n */\npublic clear() {\n    this.store.dispatch(new ClearStoreAction());\n  }\n/**\n * Compacts the store by removing unreferences and unchanges resources.\n * @return {?}\n */\npublic compact() {\n    this.store.dispatch(new CompactStoreAction());\n  }\n/**\n * Adds the given errors to the resource with the given id.\n * @param {?} id\n * @param {?} errors\n * @return {?}\n */\npublic addResourceErrors(\n    id: ResourceIdentifier,\n    errors: Array<ResourceError>\n  ) {\n    this.store.dispatch(\n      new ModifyStoreResourceErrorsAction({\n        resourceId: id,\n        errors: errors,\n        modificationType: 'ADD',\n      })\n    );\n  }\n/**\n * Removes the given errors to the resource with the given id.\n * @param {?} id\n * @param {?} errors\n * @return {?}\n */\npublic removeResourceErrors(\n    id: ResourceIdentifier,\n    errors: Array<ResourceError>\n  ) {\n    this.store.dispatch(\n      new ModifyStoreResourceErrorsAction({\n        resourceId: id,\n        errors: errors,\n        modificationType: 'REMOVE',\n      })\n    );\n  }\n/**\n * Sets the given errors to the resource with the given id.\n * @param {?} id\n * @param {?} errors\n * @return {?}\n */\npublic setResourceErrors(\n    id: ResourceIdentifier,\n    errors: Array<ResourceError>\n  ) {\n    this.store.dispatch(\n      new ModifyStoreResourceErrorsAction({\n        resourceId: id,\n        errors: errors,\n        modificationType: 'SET',\n      })\n    );\n  }\n}\n\nfunction NgrxJsonApiService_tsickle_Closure_declarations() {\n/** @type {?} */\nNgrxJsonApiService.prototype.test;\n/**\n * Keeps current snapshot of the store to allow fast access to resources.\n * @type {?}\n */\nNgrxJsonApiService.prototype._storeSnapshot;\n/** @type {?} */\nNgrxJsonApiService.prototype.store;\n/** @type {?} */\nNgrxJsonApiService.prototype.selectors;\n}\n\n","import { Pipe, PipeTransform } from '@angular/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport'rxjs/add/operator/let';\n\nimport { NgrxJsonApiService } from './services';\nimport { Resource, ResourceIdentifier, StoreResource } from './interfaces';\nexport class SelectStoreResourcePipe implements PipeTransform {\n/**\n * @param {?} service\n */\nconstructor(private service: NgrxJsonApiService) {}\n/**\n * @param {?} id\n * @return {?}\n */\ntransform(id: ResourceIdentifier): Observable<StoreResource> {\n    return this.service.selectStoreResource(id);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{ name: 'jaSelectStoreResource' }, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgrxJsonApiService, },\n];\n}\n\nfunction SelectStoreResourcePipe_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectStoreResourcePipe.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nSelectStoreResourcePipe.ctorParameters;\n/** @type {?} */\nSelectStoreResourcePipe.prototype.service;\n}\n\nexport class DenormaliseStoreResourcePipe implements PipeTransform {\n/**\n * @param {?} service\n */\nconstructor(private service: NgrxJsonApiService) {}\n/**\n * @param {?} obs\n * @return {?}\n */\ntransform(\n    obs: Observable<StoreResource> | Observable<StoreResource[]>\n  ): Observable<StoreResource> | Observable<StoreResource[]> {\n    return this.service.denormaliseResource(obs);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{ name: 'denormaliseStoreResource' }, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgrxJsonApiService, },\n];\n}\n\nfunction DenormaliseStoreResourcePipe_tsickle_Closure_declarations() {\n/** @type {?} */\nDenormaliseStoreResourcePipe.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDenormaliseStoreResourcePipe.ctorParameters;\n/** @type {?} */\nDenormaliseStoreResourcePipe.prototype.service;\n}\n\nexport class GetDenormalisedValuePipe implements PipeTransform {\n/**\n * @param {?} service\n */\nconstructor(private service: NgrxJsonApiService) {}\n/**\n * @param {?} path\n * @param {?} storeResource\n * @return {?}\n */\ntransform(path: string, storeResource: StoreResource): any {\n    return this.service.getDenormalisedValue(path, storeResource);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{ name: 'getDenormalisedValue' }, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgrxJsonApiService, },\n];\n}\n\nfunction GetDenormalisedValuePipe_tsickle_Closure_declarations() {\n/** @type {?} */\nGetDenormalisedValuePipe.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nGetDenormalisedValuePipe.ctorParameters;\n/** @type {?} */\nGetDenormalisedValuePipe.prototype.service;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import * as _ from 'lodash/index';\n\nimport {\n  HttpHeaders,\n  HttpClient,\n  HttpRequest,\n  // required for building\n  HttpHeaderResponse,\n  HttpProgressEvent,\n  HttpResponse,\n  HttpSentEvent,\n  HttpUserEvent,\n} from '@angular/common/http';\n\nimport { ErrorObservable } from 'rxjs/observable/ErrorObservable';\nimport { Observable } from 'rxjs/Observable';\nimport'rxjs/add/operator/map';\nimport'rxjs/add/observable/throw';\n\nimport {\n  Document,\n  NgrxJsonApiConfig,\n  OperationType,\n  ResourceDefinition,\n  Query,\n  QueryParams,\n} from './interfaces';\nimport {\n  generateIncludedQueryParams,\n  generateFieldsQueryParams,\n  generateFilteringQueryParams,\n  generateSortingQueryParams,\n  generateQueryParams,\n} from './utils';\nexport class NgrxJsonApi {\npublic headers: HttpHeaders = new HttpHeaders({\n    'Content-Type': 'application/vnd.api+json',\n    Accept: 'application/vnd.api+json',\n  });\npublic requestUrl: string;\npublic definitions = this.config.resourceDefinitions;\n/**\n * @param {?} http\n * @param {?} config\n */\nconstructor(private http: HttpClient,\npublic config: NgrxJsonApiConfig) {}\n/**\n * @param {?} query\n * @param {?} operation\n * @return {?}\n */\nprivate urlBuilder(query: Query, operation: OperationType) {\n    switch (operation) {\n      case 'GET': {\n        if (query.type && query.id) {\n          return this.resourceUrlFor(query.type, query.id);\n        } else if (query.type) {\n          return this.collectionUrlFor(query.type);\n        }\n      }\n      case 'DELETE': {\n        if (query.type && query.id) {\n          return this.resourceUrlFor(query.type, query.id);\n        }\n      }\n      case 'PATCH': {\n        if (query.type && query.id) {\n          return this.resourceUrlFor(query.type, query.id);\n        }\n      }\n      case 'POST': {\n        return this.collectionUrlFor(query.type);\n      }\n    }\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nprivate collectionPathFor(type: string) {\n    // assume that type == collectionPath if not configured otherwise\n    let /** @type {?} */ definition = _.find(this.definitions, { type: type });\n    if (definition) {\n      return `${definition.collectionPath}`;\n    } else {\n      return type;\n    }\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nprivate collectionUrlFor(type: string) {\n    let /** @type {?} */ collectionPath = this.collectionPathFor(type);\n    return `${this.config.apiUrl}/${collectionPath}`;\n  }\n/**\n * @param {?} type\n * @param {?} id\n * @return {?}\n */\nprivate resourcePathFor(type: string, id: string) {\n    let /** @type {?} */ collectionPath = this.collectionPathFor(type);\n    return `${collectionPath}/${encodeURIComponent(id)}`;\n  }\n/**\n * @param {?} type\n * @param {?} id\n * @return {?}\n */\nprivate resourceUrlFor(type: string, id: string) {\n    let /** @type {?} */ resourcePath = this.resourcePathFor(type, id);\n    return `${this.config.apiUrl}/${resourcePath}`;\n  }\n/**\n * @param {?} query\n * @return {?}\n */\npublic find(query: Query) {\n    let /** @type {?} */ _generateIncludedQueryParams = generateIncludedQueryParams;\n    let /** @type {?} */ _generateFilteringQueryParams = generateFilteringQueryParams;\n    let /** @type {?} */ _generateFieldsQueryParams = generateFieldsQueryParams;\n    let /** @type {?} */ _generateSortingQueryParams = generateSortingQueryParams;\n    let /** @type {?} */ _generateQueryParams = generateQueryParams;\n\n    if (this.config.hasOwnProperty('urlBuilder')) {\n      let /** @type {?} */ urlBuilder = this.config.urlBuilder;\n\n      if (urlBuilder.generateIncludedQueryParams) {\n        _generateIncludedQueryParams = urlBuilder.generateIncludedQueryParams;\n      }\n      if (urlBuilder.generateFilteringQueryParams) {\n        _generateFilteringQueryParams = urlBuilder.generateFilteringQueryParams;\n      }\n      if (urlBuilder.generateFieldsQueryParams) {\n        _generateFieldsQueryParams = urlBuilder.generateFieldsQueryParams;\n      }\n      if (urlBuilder.generateSortingQueryParams) {\n        _generateSortingQueryParams = urlBuilder.generateSortingQueryParams;\n      }\n      if (urlBuilder.generateQueryParams) {\n        _generateQueryParams = urlBuilder.generateQueryParams;\n      }\n    }\n\n    let /** @type {?} */ queryParams = '';\n    let /** @type {?} */ includedParam = '';\n    let /** @type {?} */ filteringParams = '';\n    let /** @type {?} */ sortingParams = '';\n    let /** @type {?} */ fieldsParams = '';\n    let /** @type {?} */ offsetParams = '';\n    let /** @type {?} */ limitParams = '';\n\n    if (typeof query === undefined) {\n      return Observable.throw('Query not found');\n    }\n\n    if (query.hasOwnProperty('params') && !_.isEmpty(query.params)) {\n      if (_.hasIn(query.params, 'include')) {\n        includedParam = _generateIncludedQueryParams(query.params.include);\n      }\n      if (_.hasIn(query.params, 'filtering')) {\n        filteringParams = _generateFilteringQueryParams(query.params.filtering);\n      }\n      if (_.hasIn(query.params, 'sorting')) {\n        sortingParams = _generateSortingQueryParams(query.params.sorting);\n      }\n      if (_.hasIn(query.params, 'fields')) {\n        fieldsParams = _generateFieldsQueryParams(query.params.fields);\n      }\n      if (_.hasIn(query.params, 'limit')) {\n        limitParams = 'page[limit]=' + query.params.limit;\n      }\n      if (_.hasIn(query.params, 'offset')) {\n        offsetParams = 'page[offset]=' + query.params.offset;\n      }\n    }\n    queryParams = _generateQueryParams(\n      includedParam,\n      filteringParams,\n      sortingParams,\n      fieldsParams,\n      offsetParams,\n      limitParams\n    );\n\n    let /** @type {?} */ requestOptions = {\n      method: 'GET',\n      url: this.urlBuilder(query, 'GET') + queryParams,\n    };\n\n    return this.request(requestOptions);\n  }\n/**\n * @param {?} query\n * @param {?} document\n * @return {?}\n */\npublic create(query: Query, document: Document) {\n    if (typeof query === undefined) {\n      return Observable.throw('Query not found');\n    }\n\n    if (typeof document === undefined) {\n      return Observable.throw('Data not found');\n    }\n\n    let /** @type {?} */ requestOptions = {\n      method: 'POST',\n      url: this.urlBuilder(query, 'POST'),\n      body: JSON.stringify({ data: document.data }),\n    };\n\n    return this.request(requestOptions);\n  }\n/**\n * @param {?} query\n * @param {?} document\n * @return {?}\n */\npublic update(query: Query, document: Document) {\n    if (typeof query === undefined) {\n      return Observable.throw('Query not found');\n    }\n\n    if (typeof document === undefined) {\n      return Observable.throw('Data not found');\n    }\n    let /** @type {?} */ requestOptions = {\n      method: 'PATCH',\n      url: this.urlBuilder(query, 'PATCH'),\n      body: JSON.stringify({ data: document.data }),\n    };\n\n    return this.request(requestOptions);\n  }\n/**\n * @param {?} query\n * @return {?}\n */\npublic delete(query: Query) {\n    if (typeof query === undefined) {\n      return Observable.throw('Query not found');\n    }\n\n    let /** @type {?} */ requestOptions = {\n      method: 'DELETE',\n      url: this.urlBuilder(query, 'DELETE'),\n    };\n\n    return this.request(requestOptions);\n  }\n/**\n * @param {?} requestOptions\n * @return {?}\n */\nprivate request(requestOptions: any) {\n    let /** @type {?} */ request: HttpRequest<any>;\n    let /** @type {?} */ newRequestOptions = {\n      ...requestOptions,\n      headers: this.headers,\n      observe: 'response',\n    };\n\n    if (requestOptions.method === 'GET') {\n      let { method, url, ...init } = newRequestOptions;\n      return this.http.get(url, init);\n    } else if (requestOptions.method === 'POST') {\n      let { method, url, body, ...init } = newRequestOptions;\n      return this.http.post(url, body, init);\n    } else if (requestOptions.method === 'PATCH') {\n      let { method, url, body, ...init } = newRequestOptions;\n      return this.http.patch(url, body, init);\n    } else if (requestOptions.method === 'DELETE') {\n      let { method, url, ...init } = newRequestOptions;\n      return this.http.delete(url, init);\n    }\n  }\n}\n\nfunction NgrxJsonApi_tsickle_Closure_declarations() {\n/** @type {?} */\nNgrxJsonApi.prototype.headers;\n/** @type {?} */\nNgrxJsonApi.prototype.requestUrl;\n/** @type {?} */\nNgrxJsonApi.prototype.definitions;\n/** @type {?} */\nNgrxJsonApi.prototype.http;\n/** @type {?} */\nNgrxJsonApi.prototype.config;\n}\n\n","import { Injectable, OnDestroy } from '@angular/core';\n\nimport { HttpErrorResponse, HttpResponse } from '@angular/common/http';\n\nimport * as _ from 'lodash/index';\n\nimport { Action, Store } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\n\nimport { Observable } from 'rxjs/Observable';\nimport'rxjs/add/observable/of';\nimport'rxjs/add/operator/catch';\nimport'rxjs/add/operator/concatAll';\nimport'rxjs/add/operator/do';\nimport'rxjs/add/operator/mapTo';\nimport'rxjs/add/operator/mergeMap';\nimport'rxjs/add/operator/switchMap';\nimport'rxjs/add/operator/switchMapTo';\nimport'rxjs/add/operator/take';\nimport'rxjs/add/operator/toArray';\nimport'rxjs/add/operator/withLatestFrom';\nimport'rxjs/add/operator/takeWhile';\nimport'rxjs/add/operator/takeUntil';\n\nimport {\n  ApiApplyFailAction,\n  ApiApplyInitAction,\n  ApiApplySuccessAction,\n  ApiDeleteFailAction,\n  ApiDeleteInitAction,\n  ApiDeleteSuccessAction,\n  ApiGetFailAction,\n  ApiGetInitAction,\n  ApiGetSuccessAction,\n  ApiPatchFailAction,\n  ApiPatchInitAction,\n  ApiPatchSuccessAction,\n  ApiPostFailAction,\n  ApiPostInitAction,\n  ApiPostSuccessAction,\n  ApiQueryRefreshAction,\n  LocalQueryFailAction,\n  LocalQueryInitAction,\n  LocalQuerySuccessAction,\n  NgrxJsonApiActionTypes,\n} from './actions';\nimport { NgrxJsonApi } from './api';\nimport {getNgrxJsonApiStore, NgrxJsonApiSelectors} from './selectors';\nimport {\n  NgrxJsonApiStore,\n  OperationType,\n  Payload,\n  Query,\n  Resource,\n  ResourceError,\n  ResourceIdentifier,\n  StoreResource,\n} from './interfaces';\nimport {\n  generatePayload,\n  getPendingChanges,\n  sortPendingChanges,\n} from './utils';\nexport class NgrxJsonApiEffects implements OnDestroy {\n  \n  createResource$: Observable<Action> = this.actions$\n    .ofType<ApiPostInitAction>(NgrxJsonApiActionTypes.API_POST_INIT)\n    .map(it => this.generatePayload(it.payload, 'POST'))\n    .mergeMap((payload: Payload) => {\n      return this.jsonApi\n        .create(payload.query, payload.jsonApiData)\n        .map(\n          (response: HttpResponse<any>) =>\n            new ApiPostSuccessAction({\n              jsonApiData: response.body,\n              query: payload.query,\n            })\n        )\n        .catch(error =>\n          Observable.of(\n            new ApiPostFailAction(this.toErrorPayload(payload.query, error))\n          )\n        );\n    });\n\n  \n  updateResource$ = this.actions$\n    .ofType<ApiPatchInitAction>(NgrxJsonApiActionTypes.API_PATCH_INIT)\n    .map(it => this.generatePayload(it.payload, 'PATCH'))\n    .mergeMap((payload: Payload) => {\n      return this.jsonApi\n        .update(payload.query, payload.jsonApiData)\n        .map(\n          (response: HttpResponse<any>) =>\n            new ApiPatchSuccessAction({\n              jsonApiData: response.body,\n              query: payload.query,\n            })\n        )\n        .catch(error =>\n          Observable.of(\n            new ApiPatchFailAction(this.toErrorPayload(payload.query, error))\n          )\n        );\n    });\n\n  \n  readResource$ = this.actions$\n    .ofType<ApiGetInitAction>(NgrxJsonApiActionTypes.API_GET_INIT)\n    .map(it => it.payload)\n    .mergeMap((query: Query) => {\n      return this.jsonApi\n        .find(query)\n        .map((response: HttpResponse<any>) => response.body)\n        .map(\n          data =>\n            new ApiGetSuccessAction({\n              jsonApiData: data,\n              query: query,\n            })\n        )\n        .catch(error =>\n          Observable.of(new ApiGetFailAction(this.toErrorPayload(query, error)))\n        );\n    });\n/**\n * @param {?} query\n * @return {?}\n */\nprivate localQueryInitEventFor(query: Query) {\n    return this.actions$\n      .ofType<LocalQueryInitAction>(NgrxJsonApiActionTypes.LOCAL_QUERY_INIT)\n      .map(action => /** @type {?} */(( action as LocalQueryInitAction)))\n      .filter(action => query.queryId == action.payload.queryId);\n  }\n/**\n * @param {?} query\n * @return {?}\n */\nprivate removeQueryEventFor(query: Query) {\n    return this.actions$\n      .ofType<LocalQueryInitAction>(NgrxJsonApiActionTypes.REMOVE_QUERY)\n      .map(action => /** @type {?} */(( action as LocalQueryInitAction)))\n      .filter(action => query.queryId == action.payload);\n  }\n\n  \n  queryStore$ = this.actions$\n    .ofType<LocalQueryInitAction>(NgrxJsonApiActionTypes.LOCAL_QUERY_INIT)\n    .map(it => it.payload)\n    .mergeMap((query: Query) => {\n      return this.store\n        .let(this.selectors.getNgrxJsonApiStore$())\n        .let(this.selectors.queryStore$(query))\n        .map(\n          results =>\n            new LocalQuerySuccessAction({\n              jsonApiData: { data: results },\n              query: query,\n            })\n        )\n        .catch(error =>\n          Observable.of(\n            new LocalQueryFailAction(this.toErrorPayload(query, error))\n          )\n        )\n        .takeUntil(this.localQueryInitEventFor(query))\n        .takeUntil(this.removeQueryEventFor(query));\n    });\n\n  \n  deleteResource$ = this.actions$\n    .ofType<ApiDeleteInitAction>(NgrxJsonApiActionTypes.API_DELETE_INIT)\n    .map(it => it.payload)\n    .map<ResourceIdentifier, Payload>(it => this.generatePayload(it, 'DELETE'))\n    .mergeMap((payload: Payload) => {\n      return this.jsonApi\n        .delete(payload.query)\n        .map((response: HttpResponse<any>) => response.body)\n        .map(\n          data =>\n            new ApiDeleteSuccessAction({\n              jsonApiData: data,\n              query: payload.query,\n            })\n        )\n        .catch(error =>\n          Observable.of(\n            new ApiDeleteFailAction(this.toErrorPayload(payload.query, error))\n          )\n        );\n    });\n\n  \n  triggerReadOnQueryRefresh$ = this.actions$\n    .ofType(NgrxJsonApiActionTypes.API_QUERY_REFRESH)\n    .withLatestFrom(this.store, (action: any, store) => {\n      let /** @type {?} */ queryId = action.payload;\n      let /** @type {?} */ state = /** @type {?} */(( store['NgrxJsonApi']['api'] as NgrxJsonApiStore));\n      let /** @type {?} */ query = state.queries[queryId].query;\n      return new ApiGetInitAction(query);\n    });\n\n  \n  refreshQueriesOnDelete$ = this.actions$\n    .ofType(NgrxJsonApiActionTypes.API_DELETE_SUCCESS)\n    .withLatestFrom(this.store, (action: any, store) => {\n      let /** @type {?} */ id = { id: action.payload.query.id, type: action.payload.query.type };\n      if (!id.id || !id.type) {\n        throw new Error(\n          'API_DELETE_SUCCESS did not carry resource id and type information'\n        );\n      }\n\n      let /** @type {?} */ state = /** @type {?} */(( store['NgrxJsonApi']['api'] as NgrxJsonApiStore));\n\n      let /** @type {?} */ actions = [];\n      for (let /** @type {?} */ queryId in state.queries) {\n        if (state.queries.hasOwnProperty(queryId)) {\n          let /** @type {?} */ query = state.queries[queryId];\n          if (query.resultIds) {\n            let /** @type {?} */ needsRefresh =\n              _.findIndex(query.resultIds, function(o) {\n                return _.isEqual(id, o);\n              }) !== -1;\n\n            let /** @type {?} */ sameIdRequested =\n              query.query.id === id.id && query.query.type === id.type;\n            if (sameIdRequested && (needsRefresh || _.isEmpty(query.errors))) {\n              throw new Error(\n                'store is in invalid state, queries for deleted' +\n                  ' resource should have been emptied and marked with 404 error'\n              );\n            }\n\n            if (needsRefresh) {\n              actions.push(new ApiQueryRefreshAction(queryId));\n            }\n          }\n        }\n      }\n      return actions;\n    })\n    .flatMap(actions => Observable.of(...actions));\n\n  \n  applyResources$ = this.actions$\n    .ofType(NgrxJsonApiActionTypes.API_APPLY_INIT)\n    .filter(() => this.jsonApi.config.applyEnabled !== false)\n    .withLatestFrom(\n      this.store.let(getNgrxJsonApiStore),\n      (action, ngrxstore: NgrxJsonApiStore) => {\n        let /** @type {?} */ payload = ( /** @type {?} */((action as ApiApplyInitAction))).payload;\n        const /** @type {?} */ pending: Array<StoreResource> = getPendingChanges(\n          ngrxstore.data,\n          payload.ids,\n          payload.include\n        );\n        return pending;\n      }\n    )\n    .flatMap(pending => {\n      if (pending.length === 0) {\n        return Observable.of(new ApiApplySuccessAction([]));\n      }\n      pending = sortPendingChanges(pending);\n\n      let /** @type {?} */ actions: Array<Observable<Action>> = [];\n      for (let /** @type {?} */ pendingChange of pending) {\n        if (pendingChange.state === 'CREATED') {\n          let /** @type {?} */ payload: Payload = this.generatePayload(pendingChange, 'POST');\n          actions.push(\n            this.jsonApi\n              .create(payload.query, payload.jsonApiData)\n              .map(\n                response =>\n                  new ApiPostSuccessAction({\n                    jsonApiData: response.body,\n                    query: payload.query,\n                  })\n              )\n              .catch(error =>\n                Observable.of(\n                  new ApiPostFailAction(\n                    this.toErrorPayload(payload.query, error)\n                  )\n                )\n              )\n          );\n        } else if (pendingChange.state === 'UPDATED') {\n          // prepare payload, omit links and meta information\n          let /** @type {?} */ payload: Payload = this.generatePayload(pendingChange, 'PATCH');\n          actions.push(\n            this.jsonApi\n              .update(payload.query, payload.jsonApiData)\n              .map(\n                response =>\n                  new ApiPatchSuccessAction({\n                    jsonApiData: response.body,\n                    query: payload.query,\n                  })\n              )\n              .catch(error =>\n                Observable.of(\n                  new ApiPatchFailAction(\n                    this.toErrorPayload(payload.query, error)\n                  )\n                )\n              )\n          );\n        } else if (pendingChange.state === 'DELETED') {\n          let /** @type {?} */ payload: Payload = this.generatePayload(pendingChange, 'DELETE');\n          actions.push(\n            this.jsonApi\n              .delete(payload.query)\n              .map(\n                response =>\n                  new ApiDeleteSuccessAction({\n                    jsonApiData: response.body,\n                    query: payload.query,\n                  })\n              )\n              .catch(error =>\n                Observable.of(\n                  new ApiDeleteFailAction(\n                    this.toErrorPayload(payload.query, error)\n                  )\n                )\n              )\n          );\n        } else {\n          throw new Error('unknown state ' + pendingChange.state);\n        }\n      }\n\n      return Observable.of(...actions)\n        .concatAll()\n        .toArray()\n        .map(actions => this.toApplyAction(actions));\n    });\n/**\n * @param {?} actions$\n * @param {?} jsonApi\n * @param {?} store\n * @param {?} selectors\n */\nconstructor(\nprivate actions$: Actions,\nprivate jsonApi: NgrxJsonApi,\nprivate store: Store<any>,\nprivate selectors: NgrxJsonApiSelectors\n  ) {}\n/**\n * @return {?}\n */\nngOnDestroy() {}\n/**\n * @param {?} actions\n * @return {?}\n */\nprivate toApplyAction(actions: Array<Action>): any {\n    for (let /** @type {?} */ action of actions) {\n      if (\n        action.type === NgrxJsonApiActionTypes.API_POST_FAIL ||\n        action.type === NgrxJsonApiActionTypes.API_PATCH_FAIL ||\n        action.type === NgrxJsonApiActionTypes.API_DELETE_FAIL\n      ) {\n        return new ApiApplyFailAction(actions);\n      }\n    }\n    return new ApiApplySuccessAction(actions);\n  }\n/**\n * @param {?} query\n * @param {?} response\n * @return {?}\n */\nprivate toErrorPayload(\n    query: Query,\n    response: HttpErrorResponse | any\n  ): Payload {\n    let /** @type {?} */ contentType: String = null;\n    if (response && response.headers) {\n      contentType = response.headers.get('Content-Type');\n    }\n    let /** @type {?} */ document = null;\n    if (\n      contentType != null &&\n      contentType.startsWith('application/vnd.api+json')\n    ) {\n      document = response;\n    }\n    if (\n      document &&\n      document.error &&\n      document.error.errors &&\n      document.error.errors.length > 0\n    ) {\n      return {\n        query: query,\n        jsonApiData: document.error,\n      };\n    } else {\n      // transform http to json api error\n      let /** @type {?} */ errors: Array<ResourceError> = [];\n      let /** @type {?} */ error: ResourceError = {\n        status: String(response.status),\n        code: response.statusText,\n      };\n\n      errors.push(error);\n      // got json api errors\n\n      return {\n        query: query,\n        jsonApiData: {\n          errors: errors,\n        },\n      };\n    }\n  }\n/**\n * @param {?} resource\n * @param {?} operation\n * @return {?}\n */\nprivate generatePayload(\n    resource: Resource,\n    operation: OperationType\n  ): Payload {\n    return generatePayload(resource, operation);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Actions, },\n{type: NgrxJsonApi, },\n{type: Store, },\n{type: NgrxJsonApiSelectors, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'createResource$': [{ type: Effect },],\n'updateResource$': [{ type: Effect },],\n'readResource$': [{ type: Effect },],\n'queryStore$': [{ type: Effect },],\n'deleteResource$': [{ type: Effect },],\n'triggerReadOnQueryRefresh$': [{ type: Effect },],\n'refreshQueriesOnDelete$': [{ type: Effect },],\n'applyResources$': [{ type: Effect },],\n};\n}\n\nfunction NgrxJsonApiEffects_tsickle_Closure_declarations() {\n/** @type {?} */\nNgrxJsonApiEffects.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgrxJsonApiEffects.ctorParameters;\n/** @type {?} */\nNgrxJsonApiEffects.propDecorators;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.createResource$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.updateResource$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.readResource$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.queryStore$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.deleteResource$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.triggerReadOnQueryRefresh$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.refreshQueriesOnDelete$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.applyResources$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.actions$;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.jsonApi;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.store;\n/** @type {?} */\nNgrxJsonApiEffects.prototype.selectors;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}